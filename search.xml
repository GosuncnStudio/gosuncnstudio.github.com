<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Git常用命令简介]]></title>
      <url>/2017/12/18/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p><em>欢迎对文章内容进行补充和修正~</em></p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul>
<li>本文章转自网络<a href="https://www.cnblogs.com/TaylorApril/p/6815142.html" target="_blank" rel="noopener">github常用命令汇总</a></li>
<li>如有侵权，请作者及时联系删除。</li>
</ul>
<h3 id="创立版本库"><a href="#创立版本库" class="headerlink" title="创立版本库"></a>创立版本库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir Baidu</span><br><span class="line">cd Baidu</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>
<h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t -rsa -C &quot;TaylorApril947939@gmail&quot;</span><br><span class="line">（在github上new SSH，内容为id_rsa.pub）</span><br></pre></td></tr></table></figure>
<h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（github上新建git仓库,选择REAMDE.md）</span><br><span class="line">git remote add origin git@github.com:TaylorApril/Baidu.git</span><br><span class="line">git push -u origin master</span><br><span class="line">（报错）</span><br><span class="line">git pull --rebase origin master</span><br><span class="line">git push -u origin master</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<h3 id="提交-文件名字read-txt"><a href="#提交-文件名字read-txt" class="headerlink" title="提交(文件名字read.txt)"></a>提交(文件名字read.txt)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add read.txt</span><br><span class="line">（所有文件 git add .）</span><br><span class="line">git commit -m &quot;说明文字&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（查看最近到最远提交日志）</span><br><span class="line">git log --prtty=oneline</span><br><span class="line">（回退版本计数：HEAD^上一个版本、HEAD~100上与100个版本）</span><br><span class="line">git reset --hard HEAD^</span><br><span class="line">（回退版本号码：回退版本commit id为3628df）</span><br><span class="line">git reset --hard 3628df</span><br><span class="line">（想要恢复:使用命令记录来找回commit id回退）</span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">———&gt;              git add files              git commit </span><br><span class="line">working directory--------------stage-------------history</span><br><span class="line">&lt;———         git checkout --files         git reset --files</span><br></pre></td></tr></table></figure>
<h3 id="删除文件（read-txt）"><a href="#删除文件（read-txt）" class="headerlink" title="删除文件（read.txt）"></a>删除文件（read.txt）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rm read.txt</span><br><span class="line">（从版本库中删除）</span><br><span class="line">git rm read.txt</span><br><span class="line">git commit -m &quot;delete&quot;</span><br><span class="line">（删错了）</span><br><span class="line">git checkout -- read.txt</span><br></pre></td></tr></table></figure>
<h3 id="分支-分支名字dev"><a href="#分支-分支名字dev" class="headerlink" title="分支(分支名字dev)"></a>分支(分支名字dev)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">创建分支：git branch dev</span><br><span class="line">切换分支：git checkout dev</span><br><span class="line">创建+切换分支：git checkout -b dev</span><br><span class="line">查看当前分支：git branch</span><br><span class="line">切换回master分支：git checkout master</span><br><span class="line">合并指定分支到当前分支：git merge dev</span><br><span class="line">(fast-forward 快进模式)</span><br><span class="line">删除分支：git branch -d dev</span><br></pre></td></tr></table></figure>
<h3 id="解决冲突-分支名字fea"><a href="#解决冲突-分支名字fea" class="headerlink" title="解决冲突(分支名字fea)"></a>解决冲突(分支名字fea)</h3><ul>
<li>冲突原因：master和Dev同时增长。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b fea</span><br><span class="line">（修改Creating a new branch is quick AND simple.）</span><br><span class="line">git add read.txt</span><br><span class="line">git commit -m &quot;fea&quot;</span><br><span class="line">git checkout master</span><br><span class="line">（修改Creating a new branch is quick &amp; simple.）</span><br><span class="line">git addread.txt</span><br><span class="line">git commit -m &quot;master&quot;</span><br><span class="line">（此时形成了master和fea各自指着一个分支）</span><br><span class="line">git merge fea</span><br><span class="line">（合并错误，git status , cat read.txt可以查看）</span><br><span class="line">（修改read.txt的文本内容 Creating a new branch is quick and simple.）</span><br><span class="line">git add read.txt</span><br><span class="line">git commit -m “conf”</span><br><span class="line">（现在master和fea指向同一个人点了，git log可查看合并情况）</span><br><span class="line">git branch -d fea</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="分支管理策略（–no-ff）（分支名字dev-文件名字read-txt）"><a href="#分支管理策略（–no-ff）（分支名字dev-文件名字read-txt）" class="headerlink" title="分支管理策略（–no-ff）（分支名字dev 文件名字read.txt）"></a>分支管理策略（–no-ff）（分支名字dev 文件名字read.txt）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br><span class="line">git add read.txt</span><br><span class="line">git commit -m &quot;dev&quot;</span><br><span class="line">git checkout master</span><br><span class="line">（注意下个参数--no-ff,表示禁用fast forward）</span><br><span class="line">（fast forward合并看不出曾经做过合并，而--no-ff参数合并后的历史有分支，negative看出曾经做过合并）</span><br><span class="line">git merge --no-ff -m &quot;merge with --no-ff&quot; dev</span><br><span class="line">（查看分支历史 git log --graph --pretty=oneline --abbrev-commit）</span><br></pre></td></tr></table></figure>
<h3 id="bug分支-bugg分支为要解决bug的分支"><a href="#bug分支-bugg分支为要解决bug的分支" class="headerlink" title="bug分支(bugg分支为要解决bug的分支)"></a>bug分支(bugg分支为要解决bug的分支)</h3><ul>
<li>思想：当手头还有工作时，先将工作现场git stash(避免bug修复好后将为完成的工作一起提交),然后修复bug、提交之后，在用git stash pop将原来的工作显示在工作区 。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">（git status查看状态）</span><br><span class="line">git stash</span><br><span class="line">git checkout -b bugg</span><br><span class="line">（修改bug后）</span><br><span class="line">git add bugg.txt</span><br><span class="line">git commit -m &quot;fixed bug&quot;</span><br><span class="line">git checkout master</span><br><span class="line">git merge --no-ff -m &quot;merge bug&quot; bugg</span><br><span class="line">git branch -d bugg</span><br><span class="line">（接下来回到dev上继续工作）</span><br><span class="line">git checkout dev</span><br><span class="line">（查看工作区git status）</span><br><span class="line">（用git stash list查看）</span><br><span class="line">git stash list</span><br><span class="line">（恢复的第一种方法：恢复的同时把stash内容同时删除）</span><br><span class="line">git stash pop</span><br><span class="line">（恢复的第二种方法：恢复的同时不删除stash内容）</span><br><span class="line">git stash apply</span><br><span class="line">（若使用第二种方法想删除stash则用git stash drop）</span><br><span class="line">（若是多个文件stash 可用git stash apply stash@&#123;0&#125;恢复指定的stash）</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="feature分支-分支为dev"><a href="#feature分支-分支为dev" class="headerlink" title="feature分支(分支为dev)"></a>feature分支(分支为dev)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（在没完全完成合并时强行删除）</span><br><span class="line">git branch -D dev</span><br></pre></td></tr></table></figure>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（查看远程库信息）</span><br><span class="line">git remote</span><br><span class="line">（查看远程库更详细信息）</span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<h3 id="推送dev分支"><a href="#推送dev分支" class="headerlink" title="推送dev分支"></a>推送dev分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev</span><br></pre></td></tr></table></figure>
<h3 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">（克隆）</span><br><span class="line">git clone git@github.com:TaylorApril/test.git</span><br><span class="line">（查看能见分支 git branch）</span><br><span class="line">（在dev分支上开发，创建远程origin的dev分支到本地）</span><br><span class="line">git checkout -b dev origin/dev</span><br><span class="line">（修改后，进行提交）</span><br><span class="line">git commit -m &quot;add&quot;</span><br><span class="line">git push origin dev</span><br><span class="line">（在他提交之后你再push的情况时）</span><br><span class="line">（指定本地dev分支与远程origin分支链接）</span><br><span class="line">git branch</span><br><span class="line">git pull</span><br><span class="line">git commit -m &quot;fixed&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><h4 id="报错1"><a href="#报错1" class="headerlink" title="报错1"></a>报错1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">To git@github.com:TaylorApril/test.git</span><br><span class="line">! [rejected] master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to &apos;git@github.com:TaylorApril/test.git&apos;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &apos;git pull ...&apos;) before pushing again.</span><br><span class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</span><br></pre></td></tr></table></figure>
<ul>
<li>解决：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin master</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="报错2"><a href="#报错2" class="headerlink" title="报错2"></a>报错2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">Your branch is ahead of &apos;origin/master&apos; by 1 commit.</span><br><span class="line">(use &quot;git push&quot; to publish your local commits)</span><br></pre></td></tr></table></figure>
<ul>
<li>解决：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[视频码流格式解析]]></title>
      <url>/2017/12/15/%E8%A7%86%E9%A2%91%E7%A0%81%E6%B5%81%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="视频码流格式解析"><a href="#视频码流格式解析" class="headerlink" title="视频码流格式解析"></a>视频码流格式解析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在做视频直播功能的时候，接触到很多视频的相关概念，这些概念如果不了解，功能开发很难进行下去。本文仅用于记录在开发过程中接触到的关于H.264及H.265码流格式相关内容。</p>
<h2 id="视频封装格式"><a href="#视频封装格式" class="headerlink" title="视频封装格式"></a>视频封装格式</h2><p>在日常接触电脑视频文件的时候,可以发现视频文件通常会有不同的格式,用不同的后缀表示:avi,rmvb,mp4,flv等等。需要注意的是，这里的格式代表的是封装格式。封装格式是一种将音视频数据打包成一个文件的规范，其主要作用是把视频码流和音频码流按照一定的格式存储在一个文件中用以应对不同的播放需求。封装格式并不对视频图帧进行压缩，不同的封装格式对文件体积影响较小。<br><a id="more"></a><br>不同的视频封装格式里面存放的数据可能采用了多种不同的编码方式，现如今流行的封装格式如下表：</p>
<table>
<thead>
<tr>
<th>封装格式</th>
<th>推出机构</th>
<th>流媒体支持</th>
<th>视频编码支持</th>
<th>音频编码支持</th>
<th>使用领域</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVI</td>
<td>Microsoft Inc.</td>
<td>不支持</td>
<td>几乎所有格式</td>
<td>几乎所有格式</td>
<td>BT下载影视</td>
</tr>
<tr>
<td>MP4</td>
<td>MPEG</td>
<td>支持</td>
<td>MPEG-2,MPEG-4,H.264,H.263等</td>
<td>AAC,MPEG-1等</td>
<td>互联网视频网站</td>
</tr>
<tr>
<td>TS</td>
<td>MPEG</td>
<td>支持</td>
<td>MPEG-2,H.264,MPEG-4</td>
<td>AAC,MPEG-1等</td>
<td>数字电视</td>
</tr>
<tr>
<td>FLV</td>
<td>Adobe Inc.</td>
<td>支持</td>
<td>H.264,VP6</td>
<td>MP3,ACC,Linear PCM等</td>
<td>互联网视频网站</td>
</tr>
<tr>
<td>MKV</td>
<td>CoreCode Inc.</td>
<td>支持</td>
<td>几乎所有格式</td>
<td>几乎所有格式</td>
<td>互联网视频网站</td>
</tr>
</tbody>
</table>
<p>详细数据可<a href="http://en.wikipedia.org/wiki/Comparison_of_container_formats" target="_blank" rel="noopener">参考这里</a>。<br>从此表中可以发现，主流视频封装格式中，除了AVI之外，其他封装格式都支持流媒体。</p>
<h2 id="视频编码格式"><a href="#视频编码格式" class="headerlink" title="视频编码格式"></a>视频编码格式</h2><p>视频编码的主要作用是将视频像素数据（RGB，YUV等）压缩成为视频码流，从而降低视频数据量。当前主流的视频编码方案是H.264，H.265则将是未来编码趋势。</p>
<h3 id="H-264-AVC"><a href="#H-264-AVC" class="headerlink" title="H.264/AVC"></a>H.264/AVC</h3><p>H.264又称为<strong>MPEG-4第10部分，高级视频编码</strong>（MPEG-4 Part 10,Advanced Video Coding ,缩写为MPEG-4 AVC），是一种面向块，基于<a href="https://zh.wikipedia.org/wiki/运动补偿" target="_blank" rel="noopener">运动补偿</a>的<a href="https://en.wikipedia.org/wiki/Video_coding_format" target="_blank" rel="noopener">视频编码标准</a>。需要理解的是，H.264仅仅是一个编码标准，而不是一个具体的编码器，H.264只是给编码器的实现提供参照用的。<br>在H.264标准中，网络抽象层（NAL）和视频编码层（VCL）是两个主要概念：VCL即被压缩编码之后的视频数据序列，VCL数据与一些非VCL的视频描述数据封装成NAL数据，多个NAL单元（NALU）组成了H.264文件。</p>
<h4 id="NALU"><a href="#NALU" class="headerlink" title="NALU"></a>NALU</h4><p>NALU(Network Abstraction Layer Units，网络抽象层单元)是NAL的基本语法结构，每个NALU含一个字节的头信息以及封装了视频数据和配置数据的原始字节序列载荷（RBSP,Raw Byte Sequence Payload）字节流。</p>
<table><tr><td colspan="5" align="center">NAL结构</td></tr><tr><td>NALU header</td><td>RBSP</td><td>NALU header</td><td>RBSP</td><td>…</td></tr></table>

<p>每个NALU都可以被单独的解析和处理，但这并不代表一个单独的NALU数据就意味着是一个独立的帧，一个帧数据可以被分割成几个NALU，一个或多个NALU组成了一个Access Units（AU），AU包含了一个完整的帧。把帧分割成几个独立的NALU需要消耗许多CPU资源来进行计算，所以分割帧数据并不常用。<br>在一个NALU中，第一个字节（即NALU header）用以表示其包含数据的类型及其他信息。我们假定一个头信息字节为0x67作为例子：</p>
<table>
<thead>
<tr>
<th>十六进制</th>
<th>二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x67</td>
<td><font color="red">0</font>  <font color="green">11</font> <font color="orange">00111</font> </td>
</tr>
</tbody>
</table>
<p>如表所示，头字节可以被解析成3个部分，其中：</p>
<ul>
<li><strong><font color="red">forbidden_zero_bit</font> = 0</strong>：占1个bit，禁止位，用以检查传输过程中是否发生错误，0表示正常，1表示违反语法；</li>
<li><strong><font color="green">nal_ref_idc</font> = 3</strong>：占2个bit，用来表示当前NAL单元的优先级。非0值表示参考字段/帧/图片数据，其他不那么重要的数据则为0。对于非0值，值越大表示NALU重要性越高</li>
<li><strong><font color="orange">nal_unit_type</font> = 7</strong>：最后5位用以指定NALU类型，NALU类型定义如下</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">nal_unit_type</th>
<th style="text-align:center">NALU类型</th>
<th style="text-align:center">nal_ref_idc</th>
<th style="text-align:center">数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">未规定</td>
<td style="text-align:center"></td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">非IDR图片</td>
<td style="text-align:center">2，3，4</td>
<td style="text-align:center">VCL</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">编码片数据分区A</td>
<td style="text-align:center">2</td>
<td style="text-align:center">VCL</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">编码片数据分区B</td>
<td style="text-align:center">3</td>
<td style="text-align:center">VCL</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">编码片数据分区C</td>
<td style="text-align:center">4</td>
<td style="text-align:center">VCL</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">IDR图片</td>
<td style="text-align:center">2，3</td>
<td style="text-align:center">VCL</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">补充增强信息（SEI）</td>
<td style="text-align:center">5</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">序列参数集（SPS）</td>
<td style="text-align:center">0</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">图片参数集（PPS）</td>
<td style="text-align:center">1</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">访问单元分隔符</td>
<td style="text-align:center">6</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">序列结束</td>
<td style="text-align:center">7</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">码流结束</td>
<td style="text-align:center">8</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">填充数据</td>
<td style="text-align:center">9</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">序列参数集扩展</td>
<td style="text-align:center">10</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">NALU前缀</td>
<td style="text-align:center">2</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">序列参数集子集</td>
<td style="text-align:center">0</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">16-18</td>
<td style="text-align:center">保留</td>
<td style="text-align:center"></td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center">没有分区的辅助编码图片切片</td>
<td style="text-align:center">2，3，4</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">编码片扩展</td>
<td style="text-align:center">2，3，4</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td style="text-align:center">深度试图组建编码片扩展</td>
<td style="text-align:center">2，3，4</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">22-23</td>
<td style="text-align:center">保留</td>
<td style="text-align:center"></td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">24-31</td>
<td style="text-align:center">不明</td>
<td style="text-align:center"></td>
<td style="text-align:center">非VCL</td>
</tr>
</tbody>
</table>
<p>从表中我们可以获知,NALU类型1-5为视频帧，其余则为非视频帧。在解码过程中，我们只需要取出NALU头字节的后5位，即将NALU头字节和<code>0x1F</code>进行与计算即可得知NALU类型，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NALU类型 = NALU头字节 &amp; 0x1F</span><br></pre></td></tr></table></figure>
<p>在NALU类型数据中，我们除了需要关注VCL数据之外，还需要关注另外两个数据类型：SPS和PPS。</p>
<h5 id="SPS"><a href="#SPS" class="headerlink" title="SPS"></a>SPS</h5><p>SPS(Sequence Parameter Set,序列参数集)，NALU数据类型为7。SPS中保存了一组编码视频序列的全局参数，包括计算图像宽度及高度的参数、参考帧数等。在H.264中SPS的信息至关重要，如果其中的数据丢失或出错，那么解码过程很可能会失败。</p>
<h5 id="PPS"><a href="#PPS" class="headerlink" title="PPS"></a>PPS</h5><p>PPS(Picture Parameter Set,图像参数集),NALU数据类型为8，其中包含视频熵编码标识（用以表示码流中熵编码/解码选择的算法）、视频宏块进行帧内预测使用的宏块信息等。</p>
<p>在视频解码过程中，SPS和PPS包含了初始化H.264解码器所需要的信息参数。</p>
<h4 id="码流格式"><a href="#码流格式" class="headerlink" title="码流格式"></a>码流格式</h4><p>H.264标准中指定了视频如何编码成独立的包，但如何存储和传输这些包却未作规范，虽然标准中包含了一个Annex附件，里面描述了一种可能的格式Annex B，但这并不是一个必须要求的格式。<br>为了针对不同的存储传输需求，出现了两种打包方法。一种即Annex B格式，另一种称为AVCC格式。</p>
<h5 id="Annex-B"><a href="#Annex-B" class="headerlink" title="Annex B"></a>Annex B</h5><p>从上文可知，一个NALU中的数据并未包含他的大小（长度）信息，因此我们并不能简单的将一个个NALU连接起来生成一个流，因为数据流的接收端并不知道一个NALU从哪里结束，另一个NALU从哪里开始。<br>Annex B格式用起始码（Start Code）来解决这个问题，它在每个NALU的开始处添加三字节或四字节的起始码<code>0x000001</code>或<code>0x00000001</code>。通过定位起始码，解码器就可以很容易的识别NALU的边界。<br>当然，用起始码定位NALU边界存在一个问题，即NALU中可能存在与起始码相同的数据。为了防止这个问题，在构建NALU时，需要将数据中的<code>0x000000</code>,<code>0x000001</code>,<code>0x000002</code>,<code>0x000003</code>中插入防竞争字节（Emulation Prevention Bytes)<code>0x03</code>，使其变为：</p>
<ul>
<li>0x000000 = 0x0000 <font color="red">03</font> 00</li>
<li>0x000001 = 0x0000 <font color="red">03</font> 01</li>
<li>0x000002 = 0x0000 <font color="red">03</font> 02</li>
<li>0x000003 = 0x0000 <font color="red">03</font> 03</li>
</ul>
<p>解码器在检测到0x000003时，将0x03抛弃，恢复原始数据。</p>
<p>由于Annex B格式每个NALU都包含起始码，所以解码器可以从视频流随机点开始进行解码，常用于实时的流格式。在这种格式中通常会周期性的重复SPS和PPS，并且经常时在每一个关键帧之前。</p>
<h5 id="AVCC"><a href="#AVCC" class="headerlink" title="AVCC"></a>AVCC</h5><p>AVCC格式不使用起始码作为NALU的分界，这种格式再每个NALU前都加上一个指定NALU长度的大端格式表示的前缀。这个前缀可以是1、2或4个字节，所以在解析AVCC格式的时候需要将指定的前缀字节数的值保存在一个头部对象中，这个都通常称为<code>extradata</code>或者<code>sequence header</code>。同时，SPS和PPS数据也需要保存在<code>extradata</code>中。<br>H.264 extradata语法如下：</p>
<table>
<thead>
<tr>
<th>bits</th>
<th>line by byte</th>
<th>remark</th>
</tr>
</thead>
<tbody>
<tr>
<td>8</td>
<td>version</td>
<td>always 0x01</td>
</tr>
<tr>
<td>8</td>
<td>avc profile</td>
<td>sps[0][1]</td>
</tr>
<tr>
<td>8</td>
<td>avc compatibility</td>
<td>sps[0][2]</td>
</tr>
<tr>
<td>8</td>
<td>avc level</td>
<td>sps[0][3]</td>
</tr>
<tr>
<td>6</td>
<td>reserved</td>
<td>all bits on</td>
</tr>
<tr>
<td>2</td>
<td>NALULengthSizeMinusOne</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>reserved</td>
<td>all bits on</td>
</tr>
<tr>
<td>5</td>
<td>number of SPS NALUs</td>
<td>usually 1</td>
</tr>
<tr>
<td>16</td>
<td>SPS size</td>
<td></td>
</tr>
<tr>
<td>N</td>
<td>variable SPS NALU data</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>number of PPS NALUs</td>
<td>usually 1</td>
</tr>
<tr>
<td>16</td>
<td>PPS size</td>
<td></td>
</tr>
<tr>
<td>N</td>
<td>variable PPS NALU data</td>
</tr>
</tbody>
</table>
<p>其中第5字节的后2位表示的就是NAL size的字节数。需要注意的是，这个NALULengthSizeMinusOne是NALU前缀长度减一，即，假设前缀长度为4，那么这个值应该为3。<br>这里还需要注意的一点是，虽然AVCC格式不使用起始码，但防竞争字节还是有的。</p>
<p>AVCC格式的一个优点在于解码器配置参数在一开始就配置好了，系统可以很容易的识别NALU的边界，不需要额外的起始码，减少了资源的浪费，同时可以在播放时调到视频的中间位置。这种格式通常被用于可以被随机访问的多媒体数据，如存储在硬盘的文件。</p>
<h3 id="H-265-HEVC"><a href="#H-265-HEVC" class="headerlink" title="H.265/HEVC"></a>H.265/HEVC</h3><p>HEVC全称High Efficiency Video Coding(高效率视频编码，又称H.265)，是比H.264更家优秀的一种视频压缩标准。HEVC在低码率视频压缩上，提升视频质量、减少容量即节省带宽方面都有突出表现。<br>H.265标准围绕H.264编码标准,保留原有的某些技术，同时对一些技术进行改进，编码结构大致上和H.264的架构类似。这里着重讲一下两者编码格式的区别。<br>同H.264一样，H.265也是以NALU的形式组织起来。而在NALU header上，H.264的HALU header是一个字节，而H.265则是两个字节。我们同样假定一个头信息为0x4001作为例子：</p>
<table>
<thead>
<tr>
<th>十六进制</th>
<th>二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x4001</td>
<td><font color="red">0</font>  <font color="green">100000</font> <font color="orange">000000</font> <font color="blue">001</font></td>
</tr>
</tbody>
</table>
<p>如表所示，头信息可以被解析成4个部分，其中：</p>
<ul>
<li><strong><font color="red">forbidden_zero_bit</font> = 0</strong>：占1个bit，与H.264相同，禁止位，用以检查传输过程中是否发生错误，0表示正常，1表示违反语法；</li>
<li><strong><font color="green">nal_unit_type</font> = 32</strong>：占6个bit，用来用以指定NALU类型</li>
<li><strong><font color="orange">nuh_reserved_zero_6bits</font> = 0</strong>：占6位，预留位，要求为0，用于未来扩展或3D视频编码</li>
<li><strong><font color="blue">nuh_temporal_id_plus1</font> = 1</strong>：占3个bit，表示NAL所在的时间层ID</li>
</ul>
<p>对比H.264的头信息，H.265移除了nal_ref_idc，此信息被合并到了nal_unit_type中，H.265NALU类型规定如下:</p>
<table><tr><td>nal_unit_type</td><td>NALU类型</td><td>备注</td></tr><tr><td>0</td><td>NAL_UNIT_CODE_SLICE_TRAIL_N</td><td rowspan="10">非关键帧</td></tr><tr><td>1</td><td>NAL_UNIT_CODED_SLICE_TRAIL_R</td></tr><tr><td>2</td><td>NAL_UNIT_CODED_SLICE_TSA_N</td></tr><tr><td>3</td><td>NAL_UINT_CODED_SLICE_TSA_R</td></tr><tr><td>4</td><td>NAL_UINT_CODED_SLICE_STSA_N</td></tr><tr><td>5</td><td>NAL_UINT_CODED_SLICE_STSA_R</td></tr><tr><td>6</td><td>NAL_UNIT_CODED_SLICE_RADL_N</td></tr><tr><td>7</td><td>NAL_UNIT_CODED_SLICE_RADL_R</td></tr><tr><td>8</td><td>NAL_UNIT_CODED_SLICE_RASL_N</td>   </tr><tr><td>9</td><td>NAL_UNIT_CODE_SLICE_RASL_R</td></tr><tr><td>10 ~ 15</td><td>NAL_UNIT_RESERVED_X</td><td>保留</td></tr><tr><td>16</td><td>NAL_UNIT_CODED_SLICE_BLA_W_LP</td><td rowspan="6">关键帧</td></tr><tr><td>17</td><td>NAL_UNIT_CODE_SLICE_BLA_W_RADL</td></tr><tr><td>18</td><td>NAL_UNIT_CODE_SLICE_BLA_N_LP</td></tr><tr><td>19</td><td>NAL_UNIT_CODE_SLICE_IDR_W_RADL</td>  </tr><tr><td>20</td><td>NAL_UNIT_CODE_SLICE_IDR_N_LP</td></tr><tr><td>21</td><td>NAL_UNIT_CODE_SLICE_CRA</td></tr><tr><td>22 ~ 31</td><td>NAL_UNIT_RESERVED_X</td><td>保留</td></tr>   <tr>      <td>32</td>      <td>NAL_UNIT_VPS</td>      <td>VPS(Video Paramater Set)</td>   </tr>   <tr>      <td>33</td>     <td>NAL_UNIT_SPS</td>     <td>SPS</td>   </tr>   <tr>      <td>34</td>    <td>NAL_UNIT_PPS</td>      <td>PPS</td>   </tr>   <tr>      <td>35</td>     <td>NAL_UNIT_ACCESS_UNIT_DELIMITER</td>     <td></td>  </tr>  <tr>     <td>36</td>     <td>NAL_UNIT_EOS</td>     <td></td>  </tr>  <tr>     <td>37</td>      <td>NAL_UNIT_EOB</td>      <td></td>   </tr>   <tr>      <td>38</td>      <td>NAL_UNIT_FILLER_DATA</td>      <td></td>   </tr>   <tr>      <td>39</td>      <td>NAL_UNIT_SEI</td>      <td>Prefix SEI</td>   </tr>  <tr>      <td>40</td>      <td>NAL_UNIT_SEI_SUFFIX</td>      <td>Suffix SEI</td>   </tr>   <tr>     <td>41 ~ 47</td>      <td>NAL_UNIT_RESERVED_X</td>      <td>保留</td>   </tr>   <tr>      <td>48 ~ 63</td>      <td>NAL_UNIT_UNSPECIFIED_X</td>      <td>未规定</td>   </tr>   <tr>      <td>64</td>      <td>NAL_UNIT_INVALID</td>      <td></td>   </tr></table>

<p>具体type含义可以<a href="https://tools.ietf.org/html/draft-ietf-payload-rtp-h265-15" target="_blank" rel="noopener">参考这篇文档</a>第3.2节。<br>H.265的NALU类型是在信息头的第一个字节的第2到7位，所以判断H.265NALU类型的方法是将NALU第一个字节与<code>0x7E</code>进行与操作并右移一位，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NALU类型 = (NALU头第一字节 &amp; 0x7E) &gt;&gt; 1</span><br></pre></td></tr></table></figure>
<p>与H.264类似，H.265码流也有两种封装格式，一种是用起始码作为分界的Annex B格式，另一种则是在NALU头添加NALU长度前缀的格式，称为HVCC。在HVCC中，同样需要一个extradata来保存视频流的编解码参数，其格式定义如下：</p>
<table>   <tr>      <td>bits</td>      <td>line by byte</td>      <td>remark</td>   </tr>   <tr>      <td>8</td> <td>configurationVersion</td>      <td>always 0x01</td>   </tr>   <tr>      <td>2</td>      <td>general_profile_space</td>      <td></td>   </tr>   <tr>      <td>1</td>      <td>general_tier_flag</td>    <td></td>   </tr>  <tr>      <td>5</td>      <td>general_profile_idc</td>      <td></td>  </tr>   <tr>      <td>32</td>      <td>general_profile_compatibility_flags</td>     <td></td>   </tr>   <tr>      <td>48</td>      <td>general_constraint_indicator_flags</td>      <td></td>   </tr>   <tr>     <td>8</td>      <td>general_level_idc</td>      <td></td>   </tr>   <tr>      <td>4</td>     <td>reserved</td>      <td>‘1111’b</td>   </tr>   <tr>      <td>12</td>      <td>min_spatial_segmentation_idc</td>      <td></td>   </tr>  <tr>      <td>6</td>      <td>reserved</td>      <td>‘111111’b</td>   </tr>   <tr>      <td>2</td>    <td>parallelismType</td>      <td></td>   </tr>   <tr>      <td>6</td>      <td>reserved</td>      <td>‘111111’b</td>   </tr>   <tr>      <td>2</td>      <td>chromaFormat</td>      <td></td>   </tr>   <tr>      <td>5</td>      <td>reserved</td>     <td>‘11111’b</td>   </tr>   <tr>      <td>3</td>      <td>bitDepthLumaMinus8</td>     <td></td>   </tr>   <tr>      <td>5</td>      <td>reserved</td>      <td>‘11111’b</td>   </tr>   <tr>      <td>3</td>      <td>bitDepthChromaMinus8</td>      <td></td>   </tr>   <tr>      <td>16</td>     <td>avgFrameRate</td>     <td></td>   </tr>   <tr>      <td>2</td>      <td>constantFrameRate</td>      <td></td>   </tr>   <tr>      <td>3</td>      <td>numTemporalLayers</td>     <td></td>   </tr>   <tr>      <td>1</td>      <td>tmporalIdNested</td>      <td></td>   </tr>   <tr>      <td>2</td>      <td>lengthSizeMinusOne</td>      <td></td>   </tr>   <tr>      <td>8</td>      <td>numOfArrays</td>      <td></td>  </tr>   <tr>      <td colspan="3"> Repeated of Array(VPS/SPS/PPS)</td>   </tr>   <tr>      <td>1</td>      <td>array_completeness</td>      <td></td>   </tr>   <tr>      <td>1</td>      <td>reserved</td>      <td>‘0’b</td>   </tr>   <tr>      <td>6</td>      <td>NAL_unit_type</td>      <td></td>   </tr>   <tr>     <td>16</td>      <td>numNalus</td>      <td></td>   </tr>   <tr>      <td>16</td>      <td>nalUnitLength</td>      <td></td>   </tr>   <tr>      <td>N</td>      <td>NALU data</td>     <td></td>   </tr></table>

<p>从上表可以看到，在H.265的extradata后半段是一段格式重复的数组数据，里面需要包含的除了与H.264相同的SPS、PPS外，还需多添加一个VPS。</p>
<p>VPS（Video Parament Set,视频参数集),在H.265中类型为32。VPS用于解释编码过的视频的整体结构，包括时域子层依赖关系等，主要目的在于兼容H.265标准在系统的多子层方面的扩展。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="http://yumichan.net/video-processing/video-compression/introduction-to-h264-nal-unit" target="_blank" rel="noopener">Introduction to H.164</a><br>2.<a href="https://zh.wikipedia.org/wiki/H.264" target="_blank" rel="noopener">H.264 wiki</a><br>3.<a href="http://blog.csdn.net/leixiaohua1020/article/details/18893769" target="_blank" rel="noopener">音视频编解码技术零基础学习方法</a><br>4.<a href="https://stackoverflow.com/questions/24884827/possible-llocations-for-sequence-picture-parameter-sets-for-h-264-stream/24890903#24890903" target="_blank" rel="noopener">Possible Locations for Sequence/Picture Parameter Set(s) for H.264 Stream  answer by szatmary</a><br>5.<a href="https://www.cnblogs.com/TaigaCon/p/5215448" target="_blank" rel="noopener">h.264语法结构分析</a></p>
]]></content>
      
        <categories>
            
            <category> 视频编解码 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 视频码流 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[破解摩拜成为私家车的有效方法]]></title>
      <url>/2017/12/07/%E7%A0%B4%E8%A7%A3%E6%91%A9%E6%8B%9C%E6%88%90%E4%B8%BA%E7%A7%81%E5%AE%B6%E8%BD%A6%E7%9A%84%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step.1"></a>Step.1</h3><ul>
<li>找到想要预约的摩拜单车，预约即可看到单车编码</li>
</ul>
<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step.2"></a>Step.2</h3><ul>
<li>将上网开关关闭再打开，即可看到寻车铃按钮可以点击了</li>
<li>听到声音确认车辆</li>
</ul>
<h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step.3"></a>Step.3</h3><ul>
<li>手动输入编号即可</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>预约功能每天只有三次，可尝试机会不多哦</li>
<li>输错你暂时就别想再骑了</li>
</ul>
<p>毕生功力都传给你们了，不用客气。。。。。</p>
]]></content>
      
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[内存泄漏总结]]></title>
      <url>/2017/12/06/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="转-Android-内存泄漏总结"><a href="#转-Android-内存泄漏总结" class="headerlink" title="(转)Android 内存泄漏总结"></a>(转)Android 内存泄漏总结</h1><h4 id="资料总结来源于网络，如有侵权，请第一时间告知。"><a href="#资料总结来源于网络，如有侵权，请第一时间告知。" class="headerlink" title=" 资料总结来源于网络，如有侵权，请第一时间告知。 "></a><em> 资料总结来源于网络，如有侵权，请第一时间告知。 </em></h4><p>内存管理的目的就是让我们在开发中怎么有效的避免我们的应用出现内存泄漏的问题。内存泄漏大家都不陌生了，简单粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收。最近自己阅读了大量相关的文档资料，打算做个 总结 沉淀下来跟大家一起分享和学习，也给自己一个警示，以后 coding 时怎么避免这些情况，提高应用的体验和质量。</p>
<p>我会从 java 内存泄漏的基础知识开始，并通过具体例子来说明 Android 引起内存泄漏的各种原因，以及如何利用工具来分析应用内存泄漏，最后再做总结。<br><a id="more"></a></p>
<h2 id="Java-内存分配策略"><a href="#Java-内存分配策略" class="headerlink" title="Java 内存分配策略"></a>Java 内存分配策略</h2><p>Java 程序运行时的内存分配策略有三种,分别是静态分配,栈式分配,和堆式分配，对应的，三种存储策略使用的内存空间主要分别是静态存储区（也称方法区）、栈区和堆区。</p>
<ul>
<li><p>静态存储区（方法区）：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。</p>
</li>
<li><p>栈区 ：当方法被执行时，方法体内的局部变量（其中包括基础数据类型、对象的引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
</li>
<li><p>堆区 ： 又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存，也就是对象的实例。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。</p>
</li>
</ul>
<p>##栈与堆的区别：</p>
<p>在方法体内定义的（局部变量）一些基本类型的变量和对象的引用变量都是在方法的栈内存中分配的。当在一段方法块中定义一个变量时，Java 就会在栈中为该变量分配内存空间，当超过该变量的作用域后，该变量也就无效了，分配给它的内存空间也将被释放掉，该内存空间可以被重新使用。</p>
<p>堆内存用来存放所有由 new 创建的对象（包括该对象其中的所有成员变量）和数组。在堆中分配的内存，将由 Java 垃圾回收器来自动管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，这个特殊的变量就是我们上面说的引用变量。我们可以通过这个引用变量来访问堆中的对象或者数组。</p>
<p>举个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Sample &#123;</span><br><span class="line">    int s1 = 0;</span><br><span class="line">    Sample mSample1 = new Sample();</span><br><span class="line"></span><br><span class="line">    public void method() &#123;</span><br><span class="line">        int s2 = 1;</span><br><span class="line">        Sample mSample2 = new Sample();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sample mSample3 = new Sample();</span><br></pre></td></tr></table></figure>
<p>Sample 类的局部变量 s2 和引用变量 mSample2 都是存在于栈中，但 mSample2 指向的对象是存在于堆上的。<br>mSample3 指向的对象实体存放在堆上，包括这个对象的所有成员变量 s1 和 mSample1，而它自己存在于栈中。</p>
<p>结论：</p>
<p>局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储于堆中。—— 因为它们属于方法中的变量，生命周期随方法而结束。</p>
<p>成员变量全部存储与堆中（包括基本数据类型，引用和引用的对象实体）—— 因为它们属于类，类对象终究是要被new出来使用的。</p>
<p>了解了 Java 的内存分配之后，我们再来看看 Java 是怎么管理内存的。</p>
<p>##Java是如何管理内存</p>
<p>Java的内存管理就是对象的分配和释放问题。在 Java 中，程序员需要通过关键字 new 为每个对象申请内存空间 (基本类型除外)，所有的对象都在堆 (Heap)中分配空间。另外，对象的释放是由 GC 决定和执行的。在 Java 中，内存的分配是由程序完成的，而内存的释放是由 GC 完成的，这种收支两条线的方法确实简化了程序员的工作。但同时，它也加重了JVM的工作。这也是 Java 程序运行速度较慢的原因之一。因为，GC 为了能够正确释放对象，GC 必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC 都需要进行监控。</p>
<p>监视对象状态是为了更加准确地、及时地释放对象，而释放对象的根本原则就是该对象不再被引用。</p>
<p>为了更好理解 GC 的工作原理，我们可以将对象考虑为有向图的顶点，将引用关系考虑为图的有向边，有向边从引用者指向被引对象。另外，每个线程对象可以作为一个图的起始顶点，例如大多程序从 main 进程开始执行，那么该图就是以 main 进程顶点开始的一棵根树。在这个有向图中，根顶点可达的对象都是有效对象，GC将不回收这些对象。如果某个对象 (连通子图)与这个根顶点不可达(注意，该图为有向图)，那么我们认为这个(这些)对象不再被引用，可以被 GC 回收。<br>以下，我们举一个例子说明如何用有向图表示内存管理。对于程序的每一个时刻，我们都有一个有向图表示JVM的内存分配情况。以下右图，就是左边程序运行到第6行的示意图。</p>
<p><img src="http://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/1.gif" alt=""></p>
<p>Java使用有向图的方式进行内存管理，可以消除引用循环的问题，例如有三个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的。这种方式的优点是管理内存的精度很高，但是效率较低。另外一种常用的内存管理技术是使用计数器，例如COM模型采用计数器方式管理构件，它与有向图相比，精度行低(很难处理循环引用的问题)，但执行效率很高。</p>
<p>##什么是Java中的内存泄露</p>
<p>在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</p>
<p>在C++中，内存泄漏的范围更大一些。有些对象被分配了内存空间，然后却不可达，由于C++中没有GC，这些内存将永远收不回来。在Java中，这些不可达的对象都由GC负责回收，因此程序员不需要考虑这部分的内存泄露。</p>
<p>通过分析，我们得知，对于C++，程序员需要自己管理边和顶点，而对于Java程序员只需要管理边就可以了(不需要管理顶点的释放)。通过这种方式，Java提高了编程的效率。</p>
<p><img src="http://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/2.gif" alt=""></p>
<p>因此，通过以上分析，我们知道在Java中也有内存泄漏，但范围比C++要小一些。因为Java从语言上保证，任何对象都是可达的，所有的不可达对象都由GC管理。</p>
<p>对于程序员来说，GC基本是透明的，不可见的。虽然，我们只有几个函数可以访问GC，例如运行GC的函数System.gc()，但是根据Java语言规范定义， 该函数不保证JVM的垃圾收集器一定会执行。因为，不同的JVM实现者可能使用不同的算法管理GC。通常，GC的线程的优先级别较低。JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。但通常来说，我们不需要关心这些。除非在一些特定的场合，GC的执行影响应用程序的性能，例如对于基于Web的实时系统，如网络游戏等，用户不希望GC突然中断应用程序执行而进行垃圾回收，那么我们需要调整GC的参数，让GC能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行，Sun提供的HotSpot JVM就支持这一特性。</p>
<p>同样给出一个 Java 内存泄漏的典型例子，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vector v = new Vector(10);</span><br><span class="line">for (int i = 1; i &lt; 100; i++) &#123;</span><br><span class="line">    Object o = new Object();</span><br><span class="line">    v.add(o);</span><br><span class="line">    o = null;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们循环申请Object对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。</p>
<p><strong>详细Java中的内存泄漏</strong></p>
<p>1.Java内存回收机制</p>
<p>不论哪种语言的内存分配方式，都需要返回所分配内存的真实地址，也就是返回一个指针到内存块的首地址。Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控，Java会使用有向图的方法进行管理内存，实时监控对象是否可以达到，如果不可到达，则就将其回收，这样也可以消除引用循环的问题。在Java语言中，判断一个内存空间是否符合垃圾收集标准有两个：一个是给对象赋予了空值null，以下再没有调用过，另一个是给对象赋予了新值，这样重新分配了内存空间。 </p>
<p>2.Java内存泄漏引起的原因</p>
<p>内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。j</p>
<p>Java内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。具体主要有如下几大类：</p>
<p>1、静态集合类引起内存泄漏：</p>
<p>像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。 </p>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Static Vector v = new Vector(10);</span><br><span class="line">for (int i = 1; i&lt;100; i++)</span><br><span class="line">&#123;</span><br><span class="line">Object o = new Object();</span><br><span class="line">v.add(o);</span><br><span class="line">o = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。</p>
<p>2、当集合里面的对象属性被修改后，再调用remove()方法时不起作用。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Set&lt;Person&gt; set = new HashSet&lt;Person&gt;();</span><br><span class="line">Person p1 = new Person(&quot;唐僧&quot;,&quot;pwd1&quot;,25);</span><br><span class="line">Person p2 = new Person(&quot;孙悟空&quot;,&quot;pwd2&quot;,26);</span><br><span class="line">Person p3 = new Person(&quot;猪八戒&quot;,&quot;pwd3&quot;,27);</span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line">set.add(p3);</span><br><span class="line">System.out.println(&quot;总共有:&quot;+set.size()+&quot; 个元素!&quot;); //结果：总共有:3 个元素!</span><br><span class="line">p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变</span><br><span class="line"></span><br><span class="line">set.remove(p3); //此时remove不掉，造成内存泄漏</span><br><span class="line"></span><br><span class="line">set.add(p3); //重新添加，居然添加成功</span><br><span class="line">System.out.println(&quot;总共有:&quot;+set.size()+&quot; 个元素!&quot;); //结果：总共有:4 个元素!</span><br><span class="line">for (Person person : set)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(person);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、监听器</p>
<p>在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。</p>
<p>4、各种连接 </p>
<p>比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。</p>
<p>5、内部类和外部模块的引用</p>
<p>内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：<br>public void registerMsg(Object b);<br>这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。</p>
<p>6、单例模式 </p>
<p>不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏，考虑下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public A()&#123;</span><br><span class="line">B.getInstance().setA(this);</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">//B类采用单例模式</span><br><span class="line">class B&#123;</span><br><span class="line">private A a;</span><br><span class="line">private static B instance=new B();</span><br><span class="line">public B()&#123;&#125;</span><br><span class="line">public static B getInstance()&#123;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">public void setA(A a)&#123;</span><br><span class="line">this.a=a;</span><br><span class="line">&#125;</span><br><span class="line">//getter...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收。想象下如果A是个比较复杂的对象或者集合类型会发生什么情况</p>
<h2 id="Android中常见的内存泄漏汇总"><a href="#Android中常见的内存泄漏汇总" class="headerlink" title="##Android中常见的内存泄漏汇总"></a>##Android中常见的内存泄漏汇总</h2><p>###集合类泄漏</p>
<p>集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量 (比如类中的静态属性，全局性的 map 等即有静态引用或 final 一直指向它)，那么没有相应的删除机制，很可能导致集合所占用的内存只增不减。比如上面的典型例子就是其中一种情况，当然实际上我们在项目中肯定不会写这么 2B 的代码，但稍不注意还是很容易出现这种情况，比如我们都喜欢通过 HashMap 做一些缓存之类的事，这种情况就要多留一些心眼。</p>
<p>###单例造成的内存泄漏</p>
<p>由于单例的静态特性使得其生命周期跟应用的生命周期一样长，所以如果使用不恰当的话，很容易造成内存泄漏。比如下面一个典型的例子，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class AppManager &#123;</span><br><span class="line">private static AppManager instance;</span><br><span class="line">private Context context;</span><br><span class="line">private AppManager(Context context) &#123;</span><br><span class="line">this.context = context;</span><br><span class="line">&#125;</span><br><span class="line">public static AppManager getInstance(Context context) &#123;</span><br><span class="line">if (instance == null) &#123;</span><br><span class="line">instance = new AppManager(context);</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个Context，所以这个Context的生命周期的长短至关重要：</p>
<p>1、如果此时传入的是 Application 的 Context，因为 Application 的生命周期就是整个应用的生命周期，所以这将没有任何问题。</p>
<p>2、如果此时传入的是 Activity 的 Context，当这个 Context 所对应的 Activity 退出时，由于该 Context 的引用被单例对象所持有，其生命周期等于整个应用程序的生命周期，所以当前 Activity 退出时它的内存并不会被回收，这就造成泄漏了。</p>
<p>正确的方式应该改为下面这种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class AppManager &#123;</span><br><span class="line">private static AppManager instance;</span><br><span class="line">private Context context;</span><br><span class="line">private AppManager(Context context) &#123;</span><br><span class="line">this.context = context.getApplicationContext();// 使用Application 的context</span><br><span class="line">&#125;</span><br><span class="line">public static AppManager getInstance(Context context) &#123;</span><br><span class="line">if (instance == null) &#123;</span><br><span class="line">instance = new AppManager(context);</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者这样写，连 Context 都不用传进来了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">在你的 Application 中添加一个静态方法，getContext() 返回 Application 的 context，</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">context = getApplicationContext();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">   /**</span><br><span class="line">     * 获取全局的context</span><br><span class="line">     * @return 返回全局context对象</span><br><span class="line">     */</span><br><span class="line">    public static Context getContext()&#123;</span><br><span class="line">        return context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public class AppManager &#123;</span><br><span class="line">private static AppManager instance;</span><br><span class="line">private Context context;</span><br><span class="line">private AppManager() &#123;</span><br><span class="line">this.context = MyApplication.getContext();// 使用Application 的context</span><br><span class="line">&#125;</span><br><span class="line">public static AppManager getInstance() &#123;</span><br><span class="line">if (instance == null) &#123;</span><br><span class="line">instance = new AppManager();</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###匿名内部类/非静态内部类和异步线程</p>
<p>非静态内部类创建静态实例造成的内存泄漏</p>
<p>有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现这种写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">private static TestResource mResource = null;</span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line">if(mManager == null)&#123;</span><br><span class="line">mManager = new TestResource();</span><br><span class="line">&#125;</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br><span class="line">class TestResource &#123;</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。正确的做法为：</p>
<p>将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，请按照上面推荐的使用Application 的 Context。当然，Application 的 context 不是万能的，所以也不能随便乱用，对于有些地方则必须使用 Activity 的 Context，对于Application，Service，Activity三者的Context的应用场景如下：</p>
<p><img src="http://img.blog.csdn.net/20151123144226349?spm=5176.100239.blogcont.9.CtU1c4" alt=""></p>
<p>其中： NO1表示 Application 和 Service 可以启动一个 Activity，不过需要创建一个新的 task 任务队列。而对于 Dialog 而言，只有在 Activity 中才能创建</p>
<p>###匿名内部类</p>
<p>android开发经常会继承实现Activity/Fragment/View，此时如果你使用了匿名类，并被异步线程持有了，那要小心了，如果没有任何措施这样一定会导致泄露</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">...</span><br><span class="line">Runnable ref1 = new MyRunable();</span><br><span class="line">Runnable ref2 = new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ref1和ref2的区别是，ref2使用了匿名内部类。我们来看看运行时这两个引用的内存：</p>
<p><img src="http://img2.tbcdn.cn/L1/461/1/fb05ff6d2e68f309b94dd84352c81acfe0ae839e?spm=5176.100239.blogcont.10.CtU1c4" alt=""></p>
<p>可以看到，ref1没什么特别的。</p>
<p>但ref2这个匿名类的实现对象里面多了一个引用：</p>
<p>this$0这个引用指向MainActivity.this，也就是说当前的MainActivity实例会被ref2持有，如果将这个引用再传入一个异步线程，此线程和此Acitivity生命周期不一致的时候，就造成了Activity的泄露。</p>
<p>###Handler 造成的内存泄漏</p>
<p>Handler 的使用造成的内存泄漏问题应该说是最为常见了，很多时候我们为了避免 ANR 而不在主线程进行耗时操作，在处理网络任务或者封装一些请求回调等api都借助Handler来处理，但 Handler 不是万能的，对于 Handler 的使用代码编写一不规范即有可能造成内存泄漏。另外，我们知道 Handler、Message 和 MessageQueue 都是相互关联在一起的，万一 Handler 发送的 Message 尚未被处理，则该 Message 及发送它的 Handler 对象将被线程 MessageQueue 一直持有。</p>
<p>由于 Handler 属于 TLS(Thread Local Storage) 变量, 生命周期和 Activity 是不一致的。因此这种实现方式一般很难保证跟 View 或者 Activity 的生命周期保持一致，故很容易导致无法正确释放。</p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class SampleActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">private final Handler mLeakyHandler = new Handler() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">// Post a message and delay its execution for 10 minutes.</span><br><span class="line">mLeakyHandler.postDelayed(new Runnable() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123; /* ... */ &#125;</span><br><span class="line">&#125;, 1000 * 60 * 10);</span><br><span class="line"></span><br><span class="line">// Go back to the previous Activity.</span><br><span class="line">finish();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该 SampleActivity 中声明了一个延迟10分钟执行的消息 Message，mLeakyHandler 将其 push 进了消息队列 MessageQueue 里。当该 Activity 被 finish() 掉时，延迟执行任务的 Message 还会继续存在于主线程中，它持有该 Activity 的 Handler 引用，所以此时 finish() 掉的 Activity 就不会被回收了从而造成内存泄漏（因 Handler 为非静态内部类，它会持有外部类的引用，在这里就是指 SampleActivity）。</p>
<p>修复方法：在 Activity 中避免使用非静态内部类，比如上面我们将 Handler 声明为静态的，则其存活期跟 Activity 的生命周期就无关了。同时通过弱引用的方式引入 Activity，避免直接将 Activity 作为 context 传进去，见下面代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class SampleActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Instances of static inner classes do not hold an implicit</span><br><span class="line">   * reference to their outer class.</span><br><span class="line">   */</span><br><span class="line">  private static class MyHandler extends Handler &#123;</span><br><span class="line">    private final WeakReference&lt;SampleActivity&gt; mActivity;</span><br><span class="line"></span><br><span class="line">    public MyHandler(SampleActivity activity) &#123;</span><br><span class="line">      mActivity = new WeakReference&lt;SampleActivity&gt;(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">      SampleActivity activity = mActivity.get();</span><br><span class="line">      if (activity != null) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private final MyHandler mHandler = new MyHandler(this);</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Instances of anonymous classes do not hold an implicit</span><br><span class="line">   * reference to their outer class when they are &quot;static&quot;.</span><br><span class="line">   */</span><br><span class="line">  private static final Runnable sRunnable = new Runnable() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123; /* ... */ &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    // Post a message and delay its execution for 10 minutes.</span><br><span class="line">    mHandler.postDelayed(sRunnable, 1000 * 60 * 10);</span><br><span class="line"></span><br><span class="line">    // Go back to the previous Activity.</span><br><span class="line">    finish();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综述，即推荐使用静态内部类 + WeakReference 这种方式。每次使用前注意判空。</p>
<p>前面提到了 WeakReference，所以这里就简单的说一下 Java 对象的几种引用类型。</p>
<p>Java对引用的分类有 Strong reference, SoftReference, WeakReference, PhatomReference 四种。</p>
<p><img src="https://gw.alicdn.com/tps/TB1U6TNLVXXXXchXFXXXXXXXXXX-644-546.jpg" alt=""></p>
<p>在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量应用软引用和弱引用技术。</p>
<p>软/弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。利用这个队列可以得知被回收的软/弱引用的对象列表，从而为缓冲器清除已失效的软/弱引用。</p>
<p>假设我们的应用会用到大量的默认图片，比如应用中有默认的头像，默认游戏图标等等，这些图片很多地方会用到。如果每次都去读取图片，由于读取文件需要硬件操作，速度较慢，会导致性能较低。所以我们考虑将图片缓存起来，需要的时候直接从内存中读取。但是，由于图片占用内存空间比较大，缓存很多图片需要很多的内存，就可能比较容易发生OutOfMemory异常。这时，我们可以考虑使用软/弱引用技术来避免这个问题发生。以下就是高速缓冲器的雏形：</p>
<p>首先定义一个HashMap，保存软引用对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Map &lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap &lt;String, SoftReference&lt;Bitmap&gt;&gt; ();</span><br></pre></td></tr></table></figure>
<p>再来定义一个方法，保存Bitmap的软引用到HashMap。</p>
<p><img src="https://gw.alicdn.com/tps/TB1oW_FLVXXXXXuaXXXXXXXXXXX-679-717.jpg" alt=""></p>
<p>使用软引用以后，在OutOfMemory异常发生之前，这些缓存的图片资源的内存空间可以被释放掉的，从而避免内存达到上限，避免Crash发生。</p>
<p>如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。</p>
<p>另外可以根据对象是否经常使用来判断选择软引用还是弱引用。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。</p>
<p>ok，继续回到主题。前面所说的，创建一个静态Handler内部类，然后对 Handler 持有的对象使用弱引用，这样在回收时也可以回收 Handler 持有的对象，但是这样做虽然避免了 Activity 泄漏，不过 Looper 线程的消息队列中还是可能会有待处理的消息，所以我们在 Activity 的 Destroy 时或者 Stop 时应该移除消息队列 MessageQueue 中的消息。</p>
<p>下面几个方法都可以移除 Message：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void removeCallbacks(Runnable r);</span><br><span class="line"></span><br><span class="line">public final void removeCallbacks(Runnable r, Object token);</span><br><span class="line"></span><br><span class="line">public final void removeCallbacksAndMessages(Object token);</span><br><span class="line"></span><br><span class="line">public final void removeMessages(int what);</span><br><span class="line"></span><br><span class="line">public final void removeMessages(int what, Object object);</span><br></pre></td></tr></table></figure>
<p>###尽量避免使用 static 成员变量</p>
<p>如果成员变量被声明为 static，那我们都知道其生命周期将与整个app进程生命周期一样。</p>
<p>这会导致一系列问题，如果你的app进程设计上是长驻内存的，那即使app切到后台，这部分内存也不会被释放。按照现在手机app内存管理机制，占内存较大的后台进程将优先回收，yi’wei如果此app做过进程互保保活，那会造成app在后台频繁重启。当手机安装了你参与开发的app以后一夜时间手机被消耗空了电量、流量，你的app不得不被用户卸载或者静默。</p>
<p>这里修复的方法是：</p>
<p>不要在类初始时初始化静态成员。可以考虑lazy初始化。<br>架构设计上要思考是否真的有必要这样做，尽量避免。如果架构需要这么设计，那么此对象的生命周期你有责任管理起来。</p>
<p>###避免 override finalize()</p>
<p>1、finalize 方法被执行的时间不确定，不能依赖与它来释放紧缺的资源。时间不确定的原因是：<br>        虚拟机调用GC的时间不确定<br>        Finalize daemon线程被调度到的时间不确定</p>
<p>2、finalize 方法只会被执行一次，即使对象被复活，如果已经执行过了 finalize 方法，再次被 GC 时也不会再执行了，原因是：</p>
<p>含有 finalize 方法的 object 是在 new 的时候由虚拟机生成了一个 finalize reference 在来引用到该Object的，而在 finalize 方法执行的时候，该 object 所对应的 finalize Reference 会被释放掉，即使在这个时候把该 object 复活(即用强引用引用住该 object )，再第二次被 GC 的时候由于没有了 finalize reference 与之对应，所以 finalize 方法不会再执行。</p>
<p>3、含有Finalize方法的object需要至少经过两轮GC才有可能被释放。</p>
<p>###资源未关闭造成的内存泄漏</p>
<p>对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</p>
<p>###一些不良代码造成的内存压力</p>
<p>有些代码并不造成内存泄露，但是它们，或是对没使用的内存没进行有效及时的释放，或是没有有效的利用已有的对象而是频繁的申请新内存。</p>
<p>比如：<br>        Bitmap 没调用 recycle()方法，对于 Bitmap 对象在不使用时,我们应该先调用 recycle() 释放内存，然后才它设置为 null. 因为加载 Bitmap 对象的内存空间，一部分是 java 的，一部分 C 的（因为 Bitmap 分配的底层是通过 JNI 调用的 )。 而这个 recyle() 就是针对 C 部分的内存释放。<br>        构造 Adapter 时，没有使用缓存的 convertView ,每次都在创建新的 converView。这里推荐使用 ViewHolder。</p>
<p>##总结</p>
<p>对 Activity 等组件的引用应该控制在 Activity 的生命周期之内； 如果不能就考虑使用 getApplicationContext 或者 getApplication，以避免 Activity 被外部长生命周期的对象引用而泄露。</p>
<p>尽量不要在静态变量或者静态内部类中使用非静态外部成员变量（包括context )，即使要使用，也要考虑适时把外部成员变量置空；也可以在内部类中使用弱引用来引用外部类的变量。</p>
<p>对于生命周期比Activity长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样做避免内存泄漏：</p>
<pre><code>将内部类改为静态内部类
静态内部类中使用弱引用来引用外部类的成员变量
</code></pre><p>Handler 的持有的引用对象最好使用弱引用，资源释放时也可以清空 Handler 里面的消息。比如在 Activity onStop 或者 onDestroy 的时候，取消掉该 Handler 对象的 Message和 Runnable.</p>
<p>在 Java 的实现过程中，也要考虑其对象释放，最好的方法是在不使用某对象时，显式地将此对象赋值为 null，比如使用完Bitmap 后先调用 recycle()，再赋为null,清空对图片等资源有直接引用或者间接引用的数组（使用 array.clear() ; array = null）等，最好遵循谁创建谁释放的原则。</p>
<p>正确关闭资源，对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销。</p>
<p>保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期。</p>
]]></content>
      
        <categories>
            
            <category> Android 优化 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> android </tag>
            
            <tag> 内存泄露 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo使用教程]]></title>
      <url>/2017/12/05/hexo%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h3 id="下载安装Git并配置"><a href="#下载安装Git并配置" class="headerlink" title="下载安装Git并配置"></a>下载安装Git并配置</h3><p><em>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git 工具</a>，点击下载并安装。
</em>配置公钥<br>1.在终端中输入ssh-keygen -t rsa -C 你的邮箱<br>比如 ：ssh-keygen -t rsa -C  hck@.com<br>然后一直回车，就行了<br>最后得到如图<br><img src="/img/hexo使用教程/1.png" alt="1.png"><br><a id="more"></a><br>2.它会生成一个 id _rsa.pub 文件，看上面截图，它有 保存路径的地址说明，按照保存路径找到文件，打开，复制里面的内容<br>登录到github，点击右上角 小三角，出现如图<br><img src="/img/hexo使用教程/2.png" alt="2.png"></p>
<p>3.点击setting -&gt; sshkey -&gt; new ssh key（右上）<br>在页面随便填入一个title，然后key里面，把刚才复制的那个文本信息拷贝进去<br><img src="/img/hexo使用教程/3.png" alt="3.png"><br>点击add ssh key ，没有提示错误，就ok了.<br>4.测试SSH Key是否设置成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &apos;github.com (192.30.253.113)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br></pre></td></tr></table></figure>
<p>是否继续连接?输入yes<br>输出如下,则表示ssh key设置成功.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi xxxx! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure></p>
<p>5.本地用户信息配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git config -l  查看当前配置信息</span><br><span class="line">credential.helper=osxkeychain</span><br><span class="line">user.name=adlerkismet</span><br><span class="line">user.email=sckismet07@gmail.com</span><br><span class="line">filter.lfs.clean=git-lfs clean -- %f</span><br><span class="line">filter.lfs.smudge=git-lfs smudge -- %f</span><br><span class="line">filter.lfs.process=git-lfs filter-process</span><br><span class="line">filter.lfs.required=true</span><br></pre></td></tr></table></figure></p>
<p>6.全局用户信息配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name J_mialbox</span><br><span class="line">git config --global user.email J_mialbox@163.com</span><br><span class="line"></span><br><span class="line">//信息保存位置:chengaojian(用户名)</span><br><span class="line">/Users/chengaojian/.gitconfig</span><br><span class="line"></span><br><span class="line">打开gitconfig信息如下:</span><br><span class="line">[user]</span><br><span class="line">    name = J_mialbox</span><br><span class="line">    email = J_mialbox@163.com</span><br><span class="line"></span><br><span class="line">git log  --查看历史</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="下载安装node-js"><a href="#下载安装node-js" class="headerlink" title="下载安装node.js"></a>下载安装node.js</h3><p>1.<a href="https://link.jianshu.com/?t=https://nodejs.org/en/" target="_blank" rel="noopener">node.js下载地址</a><br>2.安装步骤：一路默认就行（安装路径根据自己需要更改）<br>3.windows平台下可能需要配置路径,具体看<a href="http://blog.csdn.net/xxmeng2012/article/details/51492149" target="_blank" rel="noopener">这篇文章</a>.</p>
<hr>
<h3 id="下载blog源文件备份并配置"><a href="#下载blog源文件备份并配置" class="headerlink" title="下载blog源文件备份并配置"></a>下载blog源文件备份并配置</h3><p>1.在配置完github密钥以及安装好npm的情况下,在终端cd到想要存放blog源文件的目录下,<code>git clone https://github.com/GosuncnStudio/Blog.git</code>.把博客源文件拷贝到本地路径,并与github产生依赖.<br>2.使用终端全局安装hexo,在终端输入<code>npm install -g hexo</code><br>3.在终端输入<code>npm update</code>,npm会根据<code>package.json</code>文件而自动下载依赖的包.<br>4.若没提示错误则配置完成,可使用hexo进行发布blog.</p>
<hr>
<h3 id="使用hexo发布"><a href="#使用hexo发布" class="headerlink" title="使用hexo发布"></a>使用hexo发布</h3><ul>
<li><code>hexo new &quot;文章名&quot;</code>例如<code>hexo new &quot;测试文档&quot;</code>可生成一篇名为”测试文档”的新文章,存放在/source/_post/目录下,用markdown编辑器可以打开编辑.具体的md语法参照<a href="https://gosuncnstudio.github.io/2017/12/05/hexo%E6%A0%B7%E5%BC%8F/">hexo样式</a>.</li>
<li><code>hexo clean</code> 清除编译完成的public文件夹以及数据库文件</li>
<li><code>hexo generate 或 hexo g</code> 编译源文件生产静态网页</li>
<li><code>hexo server 或 hexo s</code> 开启服务,可通过<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>预览</li>
<li><code>hexo deploy 或 hexo d</code> 部署发布到网站上</li>
<li>通常的部署只需要三步,在终端hexo clean之后,hexo g &amp;&amp; hexo d.如图<br><img src="/img/hexo使用教程/5.png" alt="5.png"></li>
<li>部署成功后把源文件的修改提交到github(地址:<a href="https://github.com/GosuncnMobile/Blog.git" target="_blank" rel="noopener">https://github.com/GosuncnMobile/Blog.git</a>)</li>
<li>第一次发布需要账号密码,看部门群公告.<br>(如果报权限拒绝，则到控制面板中找到用户账户，在普通凭据中修改github的账号密码)</li>
</ul>
<hr>
<h3 id="部署一个全新的hexo博客"><a href="#部署一个全新的hexo博客" class="headerlink" title="部署一个全新的hexo博客"></a>部署一个全新的hexo博客</h3><p>1.先配置git密钥以及安装npm.<br>2.终端输入命令：<code>npm install -g hexo</code>,全局安装hexo.<br>  若被墙,则使用<a href="http://npm.taobao.org/" target="_blank" rel="noopener">淘宝NPM镜像</a><br>  输入以下命令<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">cnpm install -g hexo-cli</span><br><span class="line">cnpm install hexo --save</span><br></pre></td></tr></table></figure></p>
<p>3.输入<code>hexo -version</code>,若出现如下信息,则安装成功.<br><img src="/img/hexo使用教程/4.jpg" alt="4.jpg"><br>4.安装<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>自动部署发布工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git  --save</span><br></pre></td></tr></table></figure></p>
<p>5.接下来的新建一个blog,cd到想要存放blog的目录.终端执行<code>hexo init</code>,要求文件夹为空.</p>
<hr>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>更多hexo的拓展使用参照<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo中文文档</a>以及<a href="http://moxfive.coding.me/yelee/" target="_blank" rel="noopener">yelee主题使用文档</a>.</p>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="http://www.jianshu.com/p/6ae3697a7c93" target="_blank" rel="noopener">Git的使用以及GitHub的配置</a><br>2.<a href="http://blog.csdn.net/hhhccckkk/article/details/50737077" target="_blank" rel="noopener">github配置密钥</a><br>3.<a href="http://www.jianshu.com/p/189fd945f38f" target="_blank" rel="noopener">搭建个人博客-hexo+github详细完整步骤</a><br>4.<a href="http://blog.csdn.net/xxmeng2012/article/details/51492149" target="_blank" rel="noopener"> NodeJS、NPM安装配置步骤(windows版本)</a></p>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo样式及md语法教程]]></title>
      <url>/2017/12/05/hexo%E6%A0%B7%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="生成一篇新文章或者界面"><a href="#生成一篇新文章或者界面" class="headerlink" title="生成一篇新文章或者界面"></a>生成一篇新文章或者界面</h3><p>进入到blog目录下,终端输入<code>hexo new [文章类型] &quot;文章名字&quot;</code>([文章类型]可以省略),可生成一篇新文章,如图<br><img src="/img/hexo样式/6.png" alt="3.png"><br>文章类型可选种类:</p>
<ul>
<li>posts 普通文章,在文章列表里面显示</li>
<li>page 界面,生成一个新界面,如开源项目主页,及优秀推荐等形式</li>
<li>drafts 草稿,保存在资源目录,但没发表在文章目录上</li>
</ul>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p><strong>注意具体标题和显示标题的#级数之间应该有空格,否则hexo可能识别不了该标题.如图</strong><br><img src="/img/hexo样式/3.png" alt="3.png"><br><a id="more"></a></p>
<hr>
<h3 id="首页显示文章的摘要设置"><a href="#首页显示文章的摘要设置" class="headerlink" title="首页显示文章的摘要设置"></a>首页显示文章的摘要设置</h3><p><strong>在正文的摘要和余下全文之间插入<code>&lt;!--more--&gt;</code>,如图</strong><br><img src="/img/hexo样式/4.png" alt="4.png"></p>
<hr>
<h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>使用格式为:<br><img src="/img/hexo样式/5.png" alt="5.png"><br>具体各种语言的languageKey,参见<a href="http://blog.csdn.net/u013553529/article/details/50629055" target="_blank" rel="noopener">md语法高亮</a></p>
<h4 id="oc"><a href="#oc" class="headerlink" title="oc"></a>oc</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)lt_setBackgroundColor:(<span class="built_in">UIColor</span> *)backgroundColor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.overlay) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setBackgroundImage:[<span class="built_in">UIImage</span> new] forBarMetrics:<span class="built_in">UIBarMetricsDefault</span>];</span><br><span class="line">        <span class="keyword">self</span>.overlay = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">-20</span>, [<span class="built_in">UIScreen</span> mainScreen].bounds.size.width, <span class="built_in">CGRectGetHeight</span>(<span class="keyword">self</span>.bounds) + <span class="number">20</span>)];</span><br><span class="line">        <span class="keyword">self</span>.overlay.userInteractionEnabled = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">self</span>.overlay.autoresizingMask = <span class="built_in">UIViewAutoresizingFlexibleWidth</span>|<span class="built_in">UIViewAutoresizingFlexibleHeight</span>;</span><br><span class="line">        [<span class="keyword">self</span> insertSubview:<span class="keyword">self</span>.overlay atIndex:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.overlay.backgroundColor = backgroundColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initAreaData</span><span class="params">(List&lt;AreaInfo&gt; data)</span> </span>&#123;</span><br><span class="line">        areaInfos = data;</span><br><span class="line">        List&lt;String&gt; list = Stream.of(data).map(AreaInfo::getName).collect(Collectors.toList());</span><br><span class="line">        adapter.setList(list);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (list.size() &lt; <span class="number">7</span>) &#123;</span><br><span class="line">            getWindow().setLayout(WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getWindow().setLayout(WindowManager.LayoutParams.WRAP_CONTENT, DensityUtils.dp2px(getApplication(), <span class="number">340</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">style</span>=<span class="string">"@style/LinearHorizontalStyle"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">"@dimen/y34"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:padding</span>=<span class="string">"0dp"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/tv_person_name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">"@style/ListItem.Item"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:paddingLeft</span>=<span class="string">"2dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">"0.6"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:text</span>=<span class="string">"欧阳雷锋"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> CMFormatDescriptionRef <span class="title">createFormatDescriptionFromH264Parameter</span><span class="params">(GSFrameParser *frameData, <span class="keyword">uint32_t</span> frameSize)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    CMFormatDescriptionRef fmt_desc = <span class="literal">NULL</span>;</span><br><span class="line">    OSStatus status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *<span class="keyword">const</span> parameterSetPointers[<span class="number">2</span>] = &#123;frameData.sps,frameData.pps&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> parmeterSetSizes[<span class="number">2</span>] = &#123;frameData.spsSize,frameData.ppsSize&#125;;</span><br><span class="line">    status = CMVideoFormatDescriptionCreateFromH264ParameterSets(kCFAllocatorDefault, <span class="number">2</span>, parameterSetPointers, parmeterSetSizes, <span class="number">4</span>, &amp;fmt_desc);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == noErr)</span><br><span class="line">        <span class="keyword">return</span> fmt_desc;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><p><code>**加黑**</code><br><strong>加黑</strong></p>
<p><code>*强调(斜体)*</code><br><em>强调(斜体)</em></p>
<p><code>~~删除线~~</code><br><del>删除线</del></p>
<hr>
<h3 id="图片与超链接"><a href="#图片与超链接" class="headerlink" title="图片与超链接"></a>图片与超链接</h3><p><strong>超链接</strong><br><code>[高新兴移动开发小组](https://gosuncnstudio.github.io/)</code><br><a href="https://gosuncnstudio.github.io/">高新兴移动开发小组</a></p>
<p><strong>网络图片调用</strong><br><code>![gosuncn](https://gosuncnstudio.github.io/img/avatar.png)</code><br><img src="https://gosuncnstudio.github.io/img/avatar.png" alt="gosuncn"></p>
<p><strong>本地图片调用</strong><br><code>![gosuncn](/img/avatar.png)</code><br><img src="/img/avatar.png" alt="gosuncn"></p>
<hr>
<h3 id="文章中添加图片的方法"><a href="#文章中添加图片的方法" class="headerlink" title="文章中添加图片的方法"></a>文章中添加图片的方法</h3><ul>
<li>图片都存放在source/img的路径下,每篇文章新建一个文件夹存放该文章所需要的图片.按顺序从1开始排列.</li>
<li>把要用的图片先放在上述的路径下,直接拖进Markdown编译器并删除引用路径<code>/img/...</code>之前的路径,就可以完成引用.如图<br><img src="/img/hexo样式/1.png" alt="1.png"></li>
</ul>
<hr>
<h3 id="添加分类和标签"><a href="#添加分类和标签" class="headerlink" title="添加分类和标签"></a>添加分类和标签</h3><ul>
<li>在每篇文章自动生成的categories添加分类(最好只有一个分类),在tags后面添加标签(可以有多个标签).如图<br><img src="/img/hexo样式/2.png" alt="2.png"></li>
</ul>
<hr>
<h3 id="github挂件"><a href="#github挂件" class="headerlink" title="github挂件"></a>github挂件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;github-widget&quot; data-repo=&quot;GosuncnStudio/AppVerMgt&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<div class="github-widget" data-repo="GosuncnStudio/AppVerMgt"></div>

<hr>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 水果        | 价格    |  数量  |</span><br><span class="line">    | --------   | -----:   | :----: |</span><br><span class="line">    | 香蕉        | $1      |   5    |</span><br><span class="line">    | 苹果        | $1      |   6    |</span><br><span class="line">    | 草莓        | $1      |   7    |</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>水果</th>
<th style="text-align:right">价格</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>香蕉</td>
<td style="text-align:right">$1</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td>苹果</td>
<td style="text-align:right">$1</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td>草莓</td>
<td style="text-align:right">$1</td>
<td style="text-align:center">7</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="http://blog.csdn.net/u013553529/article/details/50629055" target="_blank" rel="noopener">md语法高亮</a><br>2.<a href="https://www.cnblogs.com/liugang-vip/p/6337580.html" target="_blank" rel="noopener">md基本语法</a></p>
]]></content>
      
        <categories>
            
            <category> demo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GXXVideoPlayer配置]]></title>
      <url>/2017/12/04/GXXVideoPlayer%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h4 id="在Link-Binary-With-Libraries中添加libGXXVideoPlayer-a和libvideostack-a两个静态库。"><a href="#在Link-Binary-With-Libraries中添加libGXXVideoPlayer-a和libvideostack-a两个静态库。" class="headerlink" title="在Link Binary With Libraries中添加libGXXVideoPlayer.a和libvideostack.a两个静态库。"></a>在Link Binary With Libraries中添加libGXXVideoPlayer.a和libvideostack.a两个静态库。</h4><h4 id="在User-Header-Search-Paths中拖入GXXVideoPlayer和videostack两个库的地址。"><a href="#在User-Header-Search-Paths中拖入GXXVideoPlayer和videostack两个库的地址。" class="headerlink" title="在User Header Search Paths中拖入GXXVideoPlayer和videostack两个库的地址。"></a>在User Header Search Paths中拖入GXXVideoPlayer和videostack两个库的地址。</h4><p><img src="/img/GXXVideoPlayer配置/1.jpeg" alt="1.jpeg"></p>
<h4 id="在Link-Binary-With-Libraries中加入7个动态库：libstdc-6-0-9-tbd-libz-1-2-8-tbd-libz-tbd-libbz2-tbd-libiconv-tbd-VideoToolbox-framework-CoreMedia-framework"><a href="#在Link-Binary-With-Libraries中加入7个动态库：libstdc-6-0-9-tbd-libz-1-2-8-tbd-libz-tbd-libbz2-tbd-libiconv-tbd-VideoToolbox-framework-CoreMedia-framework" class="headerlink" title="在Link Binary With Libraries中加入7个动态库：libstdc++.6.0.9.tbd,libz.1.2.8.tbd,libz.tbd,libbz2.tbd,libiconv.tbd, VideoToolbox.framework,CoreMedia.framework"></a>在Link Binary With Libraries中加入7个动态库：libstdc++.6.0.9.tbd,libz.1.2.8.tbd,libz.tbd,libbz2.tbd,libiconv.tbd, VideoToolbox.framework,CoreMedia.framework</h4><a id="more"></a>
<p><img src="/img/GXXVideoPlayer配置/2.jpeg" alt="2.jpeg"></p>
<h4 id="在Other-Linker-Flags添加-ObjC-lbz2-liconv（注意大小写）"><a href="#在Other-Linker-Flags添加-ObjC-lbz2-liconv（注意大小写）" class="headerlink" title="在Other Linker Flags添加-ObjC,-lbz2,-liconv（注意大小写）"></a>在Other Linker Flags添加-ObjC,-lbz2,-liconv（注意大小写）</h4><p><img src="/img/GXXVideoPlayer配置/3.jpeg" alt="3.jpeg"></p>
<h4 id="在Preprocessor-Marcos中，Debug添加：DEBUG-1-LINUX-IOS-SD-WEBP-Release添加：-IOS-LINUX"><a href="#在Preprocessor-Marcos中，Debug添加：DEBUG-1-LINUX-IOS-SD-WEBP-Release添加：-IOS-LINUX" class="headerlink" title="在Preprocessor Marcos中，Debug添加：DEBUG=1,_LINUX,_IOS,SD_WEBP,Release添加：_IOS,_LINUX"></a>在Preprocessor Marcos中，Debug添加：DEBUG=1,_LINUX,_IOS,SD_WEBP,Release添加：_IOS,_LINUX</h4><p><img src="/img/GXXVideoPlayer配置/4.jpeg" alt="4.jpeg"></p>
<p><img src="/img/GXXVideoPlayer配置/5.jpeg" alt="5.jpeg"></p>
<p><img src="/img/GXXVideoPlayer配置/6.jpeg" alt="6.jpeg"></p>
<h4 id="把项目中至少一个文件的-m后缀改成-mm支持c-（例如修改AppDelegate-m为AppDelegate-mm）"><a href="#把项目中至少一个文件的-m后缀改成-mm支持c-（例如修改AppDelegate-m为AppDelegate-mm）" class="headerlink" title="把项目中至少一个文件的.m后缀改成.mm支持c++.（例如修改AppDelegate.m为AppDelegate.mm）"></a>把项目中至少一个文件的.m后缀改成.mm支持c++.（例如修改AppDelegate.m为AppDelegate.mm）</h4><p><img src="/img/GXXVideoPlayer配置/7.jpeg" alt="7.jpeg"></p>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
            <tag> video </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
