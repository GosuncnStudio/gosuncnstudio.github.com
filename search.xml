<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[svn与Cocoapods联用方法]]></title>
      <url>/2018/01/16/svn%E4%B8%8ECocoapods%E8%81%94%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  公司的项目都是寄托在SVN进行版本控制,目前是通过自己建立一个静态库来进行第三方库的管理.</p>
<ul>
<li>优点:多个项目可以共用同一个静态库,代码只有一份.可以随时更改里面相关的代码,通过SVN同步.</li>
<li><p>缺点:静态库无法包含资源文件,静态库编译的时候需要把全部都编译,时间较长.需要自己维护静态库里面各种第三方库的代码,很难自动的升级或者更新代码.</p>
<a id="more"></a>
<p>因此迫切需要一个类似安卓的Gradle工具来进行第三方库的管理.iOS最常用的包管理工具是CocoaPods.</p>
<blockquote>
<p>CocoaPods是一个为了Swift和Objective-C而诞生的第三方库管理工具.它已经拥有超过4万1个第三方库以及被超过三百万应用所使用.CocoaPods能够帮助你优雅简单地扩展你的项目.</p>
</blockquote>
<p>但由于SVN并不会自动忽略CocoaPods所下载的依赖库,而是会把目录下的依赖库全部上传到SVN.既浪费了SVN的储存空间,又没有达到使用CocoaPods的目的.因此需要找到一个方法来设置SVN的忽略(ignore),使只上传<code>podfile</code>这个描述第三方库依赖的文件.</p>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>1.將SVN的项目文件夹check out到本地目录</p>
<p><img src="/img/svn与Cocoapods联用方法/svn_co.png" alt="svn_co.png"></p>
<p>2.若co的文件夹中,还未建立项目,新建一个项目.并在新建项目目录下<code>pod init</code>,建立<code>podfile</code>文件.<br>3.<code>vim podfile</code>编辑podfile文件,加入所需要依赖的第三方库.</p>
<p><img src="/img/svn与Cocoapods联用方法/podfile.png" alt="svn_co.png"><br>4.<code>pod install</code>安装依赖.<br>5.<code>svn add podfile</code>将podfile配置文件加入版本控制<br>6.<code>svn propset svn:ignore Pods .</code>设置忽略Pods文件夹,注意pods后面还有一个<code>.</code></p>
<p><img src="/img/svn与Cocoapods联用方法/svn_ignore.png" alt="svn_ignore.png"><br><code>假如Pods文件夹已经加入了版本控制</code>,可以通过下列方法,从svn上移除Pods文件夹,并保留本地目录下的Pods文件夹.<br><code>svn rm --keep-local Pods</code><br>7.<code>svn commit -m&quot;XXXXXXXXXXXX&quot;</code>上传文件到svn服务器.</p>
<p><img src="/img/svn与Cocoapods联用方法/commit_result.png" alt="commit_result.png"><br><img src="/img/svn与Cocoapods联用方法/local_result.png" alt="commit_result.png"><br>对比可以看到,pods文件夹已经被成功忽略.</p>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h3><p>1.<a href="https://cocoapods.org/" target="_blank" rel="noopener">CocoaPods</a><br>2.<a href="https://stackoverflow.com/questions/116074/how-do-i-ignore-a-directory-with-svn" target="_blank" rel="noopener">怎么使用SVN ignore</a></p>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SVN </tag>
            
            <tag> CocoaPods </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[适配iOS 11总结]]></title>
      <url>/2018/01/04/%E9%80%82%E9%85%8DiOS-11%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="Human-Interface-Guideline的适配建议"><a href="#Human-Interface-Guideline的适配建议" class="headerlink" title="Human Interface Guideline的适配建议"></a>Human Interface Guideline的适配建议</h3><h4 id="遵循Safe-Area-安全区域-的界定"><a href="#遵循Safe-Area-安全区域-的界定" class="headerlink" title="遵循Safe Area(安全区域)的界定"></a>遵循Safe Area(安全区域)的界定</h4><p>您的布局应在填满全屏超视网膜显示屏的同时，保证内容和控件正确显示，且便于点按。遵守安全区域的界定，以确保您的 app 与 iPhone X 新的屏幕比例合作无间。<br><img src="/img/适配iOS-11相关解决方法/safeArea.jpeg" alt="safeArea.jpeg"><br>iOS 11 废弃了 iOS 7 之后出现的 topLayoutGuide/bottomLayoutGuide，取而代之的是safeLayoutGuide 概念。我们的UI元素都应该布局在这些区域之内，避免被各种 bar（NavgationBar、ToolBar、TabBar、StatusBar）遮挡。<br><a id="more"></a><br><img src="/img/适配iOS-11相关解决方法/safeArea1.jpeg" alt="safeArea1.jpeg"><br><img src="/img/适配iOS-11相关解决方法/safeArea2.jpeg" alt="safeArea2.jpeg"><br>如果我们用了 AutoLayout，并且开启了 safeAreaLayoutGuide，布局会自动加上这些 safeLayoutGuide，你的视图不会超出这部分 SafeArea。如图所示，如果你需要增加 Guide 的区域，那幺可以设置 UIViewController.additionalSafeAreaInsets 来增加区域。<br>默认的safeAreaLayoutGuide:<br><img src="/img/适配iOS-11相关解决方法/safeAreaLayoutGuideDefault.jpeg" alt="safeAreaLayoutGuideDefault.jpeg"><br>UIViewController.additionalSafeAreaInsets = UIEdgeInsetsMake(64, 0, 0, 0);的情况下:</p>
<p><img src="/img/适配iOS-11相关解决方法/safeAreaLayoutGuideAddition.jpeg" alt="safeAreaLayoutGuideAddition.jpeg"></p>
<h4 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h4><p>遵守安全区域的界定，在状态栏下面留出适当的空间。避免为状态栏高度预设值，这可能会导致您的内容被状态栏遮挡或形成错位。不可写死StatusBar的高度,iPhone X是44pt,其余为20pt.”如果你的 App 是隐藏 StatusBar 的，建议重新考虑。iPhone X 为用户在垂直空间上提供了更多展示余地，且状态栏中也包含了用户需要知道的信息，除非能通过隐藏状态栏带给用户额外的价值，否则苹果建议大家将状态栏还给用户。”<br>另外还有一点，用户在使用 iPhone X 打电话的时候，StatusBar 的高度也不会发生变化了。<br><img src="/img/适配iOS-11相关解决方法/statusBar.png" alt="statusBar.png"></p>
<h4 id="圆弧展示角和传感器槽"><a href="#圆弧展示角和传感器槽" class="headerlink" title="圆弧展示角和传感器槽"></a>圆弧展示角和传感器槽</h4><p>您的 app 的内容元素和控制按键应避开屏幕角落和传感器槽，让其在填满屏幕的同时不被角落切割。<br><img src="/img/适配iOS-11相关解决方法/BarConrner.png" alt="BarConrner.png"></p>
<h4 id="主屏幕指示器"><a href="#主屏幕指示器" class="headerlink" title="主屏幕指示器"></a>主屏幕指示器</h4><p>为使 app 的内容和控件始终保持清晰可见且便于点按，请确保您的 app 不会干扰主屏幕指示器。这部分的高度是34pt。<br><img src="/img/适配iOS-11相关解决方法/homeIdi.png" alt="homeIdi.png"><br><img src="/img/适配iOS-11相关解决方法/homeIndicator.jpeg" alt="homeIndicator.jpeg"></p>
<h4 id="调整视频的缩放度"><a href="#调整视频的缩放度" class="headerlink" title="调整视频的缩放度"></a>调整视频的缩放度</h4><p>Phone X 上的视频内容应填满屏幕。但是，如果这导致顶部或底部被切割，或侧面裁剪太多，则应将视频拉伸或缩小以配合屏幕。当 AVPlayerViewController 自动管理时，基于 AVPlayerLayer 的自定义视频播放器需要选择适当的初始视频重力设置，并允许用户根据自己的喜好在 aspect (固定宽高比) 和 aspectFill (固定宽高比且全屏) 观看模式之间进行切换。</p>
<blockquote>
<p>更多详细信息:<a href="https://developer.apple.com/ios/human-interface-guidelines/overview/iphone-x/" target="_blank" rel="noopener">Human Interface Guidelines</a></p>
</blockquote>
<p><img src="/img/适配iOS-11相关解决方法/videoScale.png" alt="videoScale.png"></p>
<h4 id="各个机型尺寸变化"><a href="#各个机型尺寸变化" class="headerlink" title="各个机型尺寸变化"></a>各个机型尺寸变化</h4><p><img src="/img/适配iOS-11相关解决方法/手机尺寸区别.png" alt="手机尺寸区别.png"><br>下图是 iPhone X 对比其他机型的变化部分。iPhone X 和 iPhone 8 的宽度一致，在垂直方向上多了145pt，这就意味着首页可以展示更多的内容.<br><img src="/img/适配iOS-11相关解决方法/iponeX.jpeg" alt="iponeX.jpeg"><br>iPhone X 的坐标系统以及能显示内容的区域如下图所示：<br><img src="/img/适配iOS-11相关解决方法/显示区域.jpeg" alt="显示区域.jpeg"></p>
<h3 id="消除iPhone-X展示界面的上下黑边"><a href="#消除iPhone-X展示界面的上下黑边" class="headerlink" title="消除iPhone X展示界面的上下黑边"></a>消除iPhone X展示界面的上下黑边</h3><p>设置LaunchImage中对iPhone X的启动页图,或者设置LaunchScreen.storyboard</p>
<h3 id="SearchBar适配"><a href="#SearchBar适配" class="headerlink" title="SearchBar适配"></a>SearchBar适配</h3><p>在使用SearchBar时,当hidesNavigationBarDuringPresentation为Yes时,在iPhone X以下机型会出现SearchBar上移6pt的问题.<br>出现该问题的原因是在iOS11中,SearchBar的高度改变了,从44pt变成了50pt.当默认present一个SearchResultController的时候,会隐藏NavigationBar.但是,此时SearchBar和StatusBar加起来的高度被限制成64pt,所以SearchBar的Frame会向上偏移6pt,可以通过KVO去监听SearchBar的Frame属性,当其searchBar.frame.origin.y == 14时,来更改其Frame.<br><code>使用KVO进行更改Frame不会使用户看到SearchBar视图位置的更改或者跳.</code><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在该函数中处理Frame的变化</span></span><br><span class="line"><span class="meta">#pragma mark - View Life Cycle</span></span><br><span class="line"><span class="comment">//在退出该controller后移除观察者</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidDisappear:(<span class="built_in">BOOL</span>)animated&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidDisappear:animated];</span><br><span class="line">    <span class="comment">//移除观察者</span></span><br><span class="line">    <span class="keyword">if</span> (@available(iOS <span class="number">11</span>, *)) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.sourceController.searchController.searchBar removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"frame"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#pragma mark - UISearchControllerDelegate</span></span><br><span class="line"><span class="comment">//在展示该controller之前监听searchBar的"frame"属性</span></span><br><span class="line">- (<span class="keyword">void</span>)willPresentSearchController:(<span class="built_in">UISearchController</span> *)searchController</span><br><span class="line">&#123;</span><br><span class="line">    _strSearchKey = <span class="string">@"test"</span>;</span><br><span class="line">    <span class="comment">//修复iOS 11 search bar向上偏移</span></span><br><span class="line">    <span class="keyword">if</span> (@available(iOS <span class="number">11</span>, *)) &#123;</span><br><span class="line">        [searchController.searchBar addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"frame"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#pragma mark - KVO</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> rect = [change[<span class="string">@"new"</span>] <span class="built_in">CGRectValue</span>];</span><br><span class="line">    <span class="keyword">if</span> (rect.origin.y == <span class="number">14</span>) &#123;</span><br><span class="line">        <span class="built_in">CGRect</span> temp = rect;</span><br><span class="line">        temp.origin.y = <span class="number">20</span>;</span><br><span class="line">        [<span class="keyword">self</span>.sourceController.searchController.searchBar setValue:@(temp) forKey:<span class="string">@"frame"</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (rect.size.height == <span class="number">56</span>)&#123;</span><br><span class="line">        <span class="built_in">CGRect</span> temp = rect;</span><br><span class="line">        temp.size.height = <span class="number">50</span>;</span><br><span class="line">        [<span class="keyword">self</span>.sourceController.searchController.searchBar setValue:@(temp) forKey:<span class="string">@"frame"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Navigation 集成 UISearchController<br>把你的UISearchController赋值给navigationItem，就可以实现将UISearchController集成到Navigation。<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">navigationItem.searchController <span class="comment">//iOS 11新增属性</span></span><br><span class="line">navigationItem.hideSearchBarWhenScrolling<span class="comment">//决定滑动的时候是否隐藏搜索框</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ScrollView界面偏移20pt或者64pt"><a href="#ScrollView界面偏移20pt或者64pt" class="headerlink" title="ScrollView界面偏移20pt或者64pt."></a>ScrollView界面偏移20pt或者64pt.</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>原因是iOS 11中Controller的automaticallyAdjustsScrollViewInsets属性被废弃了，所以当tableView超出安全区域时系统自动调整了SafeAreaInsets值，进而影响adjustedContentInset值，在iOS 11中决定tableView的内容与边缘距离的是adjustedContentInset属性，而不是contentInset。因为系统对adjustedContentInset值进行了调整，所以导致tableView的内容到边缘的距离发生了变化，导致tableView下移了20pt（statusbar高度）或64pt（navigationbar高度)。</p>
<h4 id="adjustContentInset属性的计算方式"><a href="#adjustContentInset属性的计算方式" class="headerlink" title="adjustContentInset属性的计算方式"></a>adjustContentInset属性的计算方式</h4><p>首先看scrollView在iOS11新增的两个属性：adjustContentInset 和 contentInsetAdjustmentBehavior。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Configure the behavior of adjustedContentInset.</span></span><br><span class="line"><span class="comment">Default is UIScrollViewContentInsetAdjustmentAutomatic.</span></span><br><span class="line"><span class="comment">*/</span><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">UIScrollViewContentInsetAdjustmentBehavior</span> contentInsetAdjustmentBehavior</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>adjustContentInset表示contentView.frame.origin偏移了scrollview.frame.origin多少；是系统计算得来的，计算方式由contentInsetAdjustmentBehavior决定。有以下几种计算方式：</p>
</blockquote>
<p>1.UIScrollViewContentInsetAdjustmentAutomatic：如果scrollview在一个automaticallyAdjustsScrollViewContentInset = YES的controller上，并且这个Controller包含在一个navigation controller中，这种情况下会设置在top &amp; bottom上 adjustedContentInset = safeAreaInset + contentInset不管是否滚动。其他情况下与UIScrollViewContentInsetAdjustmentScrollableAxes相同</p>
<p>2.UIScrollViewContentInsetAdjustmentScrollableAxes: 在可滚动方向上adjustedContentInset = safeAreaInset + contentInset，在不可滚动方向上adjustedContentInset = contentInset；依赖于scrollEnabled和alwaysBounceHorizontal / vertical = YES，scrollEnabled默认为yes，所以大多数情况下，计算方式还是adjustedContentInset = safeAreaInset + contentInset</p>
<p>3.UIScrollViewContentInsetAdjustmentNever: adjustedContentInset = contentInset</p>
<p>4.UIScrollViewContentInsetAdjustmentAlways: adjustedContentInset = safeAreaInset + contentInset</p>
<p>当contentInsetAdjustmentBehavior设置为UIScrollViewContentInsetAdjustmentNever的时候，adjustContentInset值不受SafeAreaInset值的影响。</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>设置tableView的contentInsetAdjustmentBehavior属性.<br>如果不需要系统为你设置边缘距离，可以做以下设置：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//如果iOS的系统是11.0，会有这样一个宏定义“#define __IPHONE_11_0  110000”；如果系统版本低于11.0则没有这个宏定义</span></span><br><span class="line"><span class="meta">#ifdef __IPHONE_11_0</span></span><br><span class="line"><span class="keyword">if</span> ([tableView respondsToSelector:<span class="keyword">@selector</span>(setContentInsetAdjustmentBehavior:)]) &#123;</span><br><span class="line">    tableView.contentInsetAdjustmentBehavior = <span class="built_in">UIScrollViewContentInsetAdjustmentNever</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure></p>
<p>contentInsetAdjustmentBehavior属性也是用来取代automaticallyAdjustsScrollViewInsets属性的，推荐使用这种方式。</p>
<h3 id="UITableViewStyleGrouped造成的偏移"><a href="#UITableViewStyleGrouped造成的偏移" class="headerlink" title="UITableViewStyleGrouped造成的偏移"></a>UITableViewStyleGrouped造成的偏移</h3><p>来着<a href="https://mp.weixin.qq.com/s/W1_0VrchCO50owhJNmJnuQ" target="_blank" rel="noopener">Bugly</a>的解决方法.</p>
<blockquote>
<p>tableView的style:UITableViewStyleGrouped类型，默认tableView开头和结尾是有间距的，不需要这个间距的话，可以通过实现heightForHeaderInSection方法（返回一个较小值：0.1）和viewForHeaderInSection（返回一个view）来去除头部的留白，底部同理。<br>iOS 11上发生tableView顶部有留白，原因是代码中只实现了heightForHeaderInSection方法，而没有实现viewForHeaderInSection方法。那样写是不规范的，只实现高度，而没有实现view，但代码这样写在iOS 11之前是没有问题的，iOS 11之后应该是由于开启了估算行高机制引起了bug。添加上viewForHeaderInSection方法后，问题就解决了。或者添加以下代码关闭估算行高，问题也得到解决。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.tableView.estimatedRowHeight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">self</span>.tableView.estimatedSectionHeaderHeight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">self</span>.tableView.estimatedSectionFooterHeight = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="BackButton的图片设置"><a href="#BackButton的图片设置" class="headerlink" title="BackButton的图片设置"></a>BackButton的图片设置</h3><p>iOS 11对整一个NavigationBar视图的层级进行了修改,原本设置backButton的方式不再起效.<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">UIBarButtonItem</span> appearance] setBackButtonBackgroundImage:[[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"navi_back"</span>] resizableImageWithCapInsets:<span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>)] forState:<span class="built_in">UIControlStateNormal</span> barMetrics:<span class="built_in">UIBarMetricsDefault</span>];</span><br></pre></td></tr></table></figure></p>
<p>会出现两个返回按钮,如图:<br><img src="/img/适配iOS-11相关解决方法/iOS11BackButtonOlder.jpeg" alt="iOS11BackButtonOlder.jpeg"><br>相对应的视图层级:<br><img src="/img/适配iOS-11相关解决方法/iOS11BackButtonOlderDetail.jpeg" alt="iOS11BackButtonOlderDetail.jpeg"><br>因此采用另外一种方式去设置backButton的图片:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *backImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"navi_back"</span>];</span><br><span class="line">    [[<span class="built_in">UINavigationBar</span> appearance] setBackIndicatorImage:backImage];</span><br><span class="line">    [[<span class="built_in">UINavigationBar</span> appearance] setBackIndicatorTransitionMaskImage:backImage];</span><br></pre></td></tr></table></figure></p>
<p>iOS 10下的视图层级:<br><img src="/img/适配iOS-11相关解决方法/iOS10BackButtonCurrent.jpeg" alt="iOS10BackButtonCurrent.jpeg"><br>iOS 11下的视图层级:<br><img src="/img/适配iOS-11相关解决方法/iOS11BackButtonCurrent.jpeg" alt="iOS11BackButtonCurrent.jpeg"></p>
<h3 id="去除BackTitle的方法"><a href="#去除BackTitle的方法" class="headerlink" title="去除BackTitle的方法"></a>去除BackTitle的方法</h3><p>设置BackTitle的偏移量,根据是否iOS 11分别给一个偏移量.<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//系统返回按钮处的title偏移到可视范围之外</span></span><br><span class="line">    <span class="comment">//iOS11 和 iOS11以下分别处理</span></span><br><span class="line">    <span class="built_in">UIOffset</span> offset = SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(<span class="string">@"11.0"</span>) ? <span class="built_in">UIOffsetMake</span>(<span class="number">-200</span>, <span class="number">0</span>) : <span class="built_in">UIOffsetMake</span>(<span class="number">0</span>, <span class="number">-80</span>);</span><br><span class="line">    [[<span class="built_in">UIBarButtonItem</span> appearance] setBackButtonTitlePositionAdjustment:offset forBarMetrics:<span class="built_in">UIBarMetricsDefault</span>];</span><br><span class="line">    [[<span class="built_in">UIBarButtonItem</span> appearance] setBackButtonTitlePositionAdjustment:offset forBarMetrics:<span class="built_in">UIBarMetricsCompact</span>];</span><br></pre></td></tr></table></figure></p>
<h3 id="rightBarButtonItem设置"><a href="#rightBarButtonItem设置" class="headerlink" title="rightBarButtonItem设置"></a>rightBarButtonItem设置</h3><p>因为在iOS11中leftBarButtonItems以及rightBarButtonItems的视图层级进行了更改,所有的BarItem都会放在UIButtonBarStackView里面.UIButtonBarStackView是一个相对布局.会根据item的个数自动设置各个Item间的距离以及约束.用<code>initWithCustomView:</code>生成的UIBarButtonItem在没加约束的情况下会在屏幕上错位,或者第一次能出现,当第二次视图出现时就消失,在iOS 11以下为正常.分析下视图层级发现,当不加约束的情况下,系统会给contentView外层添加一个UITAMICAdaptorView作为适配器.而加了约束之后,contentView外层便只是UIButtonBarStackView.如图.<br><code>iOS11 BarButton的contentView不添加约束的情况下的视图层级:</code><br><img src="/img/适配iOS-11相关解决方法/iOS11ItemNoConstant.jpeg" alt="iOS11ItemNoConstant.jpeg"></p>
<p><code>iOS11 BarButton的contentView添加约束的情况下的视图层级:</code><br><img src="/img/适配iOS-11相关解决方法/iOS11ItemConstant.jpeg" alt="iOS11ItemConstant.jpeg"></p>
<p><code>iOS11 之前BarButton的contentView不添加约束的情况下的视图层级:</code><br><img src="/img/适配iOS-11相关解决方法/iOS10ItemNoConstant.jpeg" alt="iOS10ItemNoConstant.jpeg"><br>因此,解决方法在iOS 11下为给contentView添加约束,若一个items里面有多个item用contentView生成的话,也是同理分别设置约束.代码如下:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_dropdownMenu = [[<span class="built_in">MKDropdownMenu</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">44</span>)];</span><br><span class="line">   <span class="keyword">self</span>.dropMenuItem = [[<span class="built_in">UIBarButtonItem</span> alloc]initWithCustomView:_dropdownMenu];</span><br><span class="line">   <span class="keyword">if</span>(@available(iOS <span class="number">11</span>, *))&#123;</span><br><span class="line">       [<span class="keyword">self</span>.dropMenuItem.customView.heightAnchor constraintEqualToConstant:<span class="number">44</span>].active = <span class="literal">YES</span>;</span><br><span class="line">       [<span class="keyword">self</span>.dropMenuItem.customView.widthAnchor constraintEqualToConstant:<span class="number">100</span>].active = <span class="literal">YES</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">self</span>.navigationItem.leftBarButtonItem = <span class="keyword">self</span>.dropMenuItem;</span><br></pre></td></tr></table></figure></p>
<h3 id="流式布局的iPhone-X适配"><a href="#流式布局的iPhone-X适配" class="headerlink" title="流式布局的iPhone X适配"></a>流式布局的iPhone X适配</h3><p>流式布局中的cell无需避开home indicator区域,直接展示即可.虽然cell的边角可能会被home indicator区域的圆角遮挡,减少某些信息.但给予用户的可视空间更大,而且与home indicator有冲突的交互操作可以上拉至安全区域进行点击.</p>
<h3 id="适配到iOS8的布局设置"><a href="#适配到iOS8的布局设置" class="headerlink" title="适配到iOS8的布局设置"></a>适配到iOS8的布局设置</h3><p>SafeArea最低适配到iOS9,但项目要求最低适配到iOS8.因此可以先使用topLayoutGuide和BottomLayoutGuide代替.</p>
<h3 id="横屏时tableview的适配"><a href="#横屏时tableview的适配" class="headerlink" title="横屏时tableview的适配"></a>横屏时tableview的适配</h3><ul>
<li>先看几个在iPhone X上适配错误的例子<br><img src="/img/适配iOS-11相关解决方法/tableViewEroor1.gif" alt="tableViewEroor1.gif"></li>
</ul>
<p><img src="/img/适配iOS-11相关解决方法/tableViewError2.gif" alt="tableViewError2.gif"></p>
<ul>
<li>头部导航栏不予许进行用户交互的，意味着上面这两种情况 Apple 官方是不允许的</li>
<li>使用官方推荐的safe Area在大多数情况下可以解决问题,但在横屏情况下还需要额外进行适配.</li>
</ul>
<p><img src="/img/适配iOS-11相关解决方法/tableViewLandError.png" alt="tableViewLandError.png"></p>
<ul>
<li>产生这个原因代码是：<code>[headerView.contentView setBackgroundColor:[UIColor headerFooterColor]]，</code>这个写法看起来没错，但是只有在 iPhone X上有问题</li>
<li>原因:</li>
</ul>
<p><img src="/img/适配iOS-11相关解决方法/tableViewLandDetail.png" alt="tableViewLandDetail.png"></p>
<ul>
<li>解决方法：设置backgroundView颜色 <code>[headerView.backgroundView setBackgroundColor:[UIColor headerFooterColor]]</code></li>
</ul>
<p><img src="/img/适配iOS-11相关解决方法/ios11tableViewLandRight.jpeg" alt="ios11tableViewLandRight.jpeg"></p>
<h3 id="隐藏底部Indicator"><a href="#隐藏底部Indicator" class="headerlink" title="隐藏底部Indicator"></a>隐藏底部Indicator</h3><p>如果业务需求需要隐藏底部Indicator(apple官方不推荐隐藏)<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在VC里面重写下面这个方法即可</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)prefersHomeIndicatorAutoHidden&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="发送原图功能"><a href="#发送原图功能" class="headerlink" title="发送原图功能"></a>发送原图功能</h3><p>对于IM的发送原图功能，iOS11启动全新的<strong>HEIC</strong>格式的图片，iPhone7以上设备+iOS11拍出的live照片是<code>.heic</code>格式图片，同一张live格式的图片，iOS10发送就没问题（转成了jpg），iOS11就不行.</p>
<ul>
<li>微信的处理方式是一比一转化成<strong>jpg</strong>格式</li>
<li>QQ和钉钉的处理方式是直接压缩,即使是原图也压缩为非原图</li>
<li>可采取微信的方案,使用以下代码转化成jpg格式<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.83能保证压缩前后图片大小是一致的</span></span><br><span class="line"><span class="comment">// 造成不一致的原因是图片的bitmap一个是8位的，一个是16位的</span></span><br><span class="line">imageData = <span class="built_in">UIImageJPEGRepresentation</span>([<span class="built_in">UIImage</span> imageWithData:imageData], <span class="number">0.83</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="权限处理"><a href="#权限处理" class="headerlink" title="权限处理"></a>权限处理</h3><p>iOS 11中,隐私权限配置发生了改变,将原来的相册访问权限放开了,现在有读写两种权限.</p>
<blockquote>
<p>iOS 11访问权限列表</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">隐私数据</th>
<th style="text-align:center">对应key值</th>
<th style="text-align:center">提示语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NFC(使用)</td>
<td style="text-align:center">NFCReaderUsageDescription</td>
<td style="text-align:center">“XXX”需要您的同意，才能使用NFC功能</td>
</tr>
<tr>
<td style="text-align:center">相册(读)</td>
<td style="text-align:center">NSPhotoLibraryUsageDescription</td>
<td style="text-align:center">“XXX”需要您的同意，才能访问相册</td>
</tr>
<tr>
<td style="text-align:center">相册(写)</td>
<td style="text-align:center">NSPhotoLibraryAddUsageDescription</td>
<td style="text-align:center">“XXX”需要您的同意，才能添加照片</td>
</tr>
<tr>
<td style="text-align:center">相机</td>
<td style="text-align:center">NSCameraUsageDescription</td>
<td style="text-align:center">“XXX”需要您的同意，才能访问相机</td>
</tr>
<tr>
<td style="text-align:center">麦克风</td>
<td style="text-align:center">NSMicrophoneUsageDescription</td>
<td style="text-align:center">“XXX”需要您的同意，才能访问麦克风</td>
</tr>
<tr>
<td style="text-align:center">位置</td>
<td style="text-align:center">NSLocationUsageDescription</td>
<td style="text-align:center">“XXX”需要您的同意，才能访问位置</td>
</tr>
<tr>
<td style="text-align:center">在使用期间访问位置(前台)</td>
<td style="text-align:center">NSLocationWhenInUseUsageDescription</td>
<td style="text-align:center">“XXX”需要您的同意，才能在使用期间访问位置</td>
</tr>
<tr>
<td style="text-align:center">始终访问位置</td>
<td style="text-align:center">NSLocationAlwaysUsageDescription</td>
<td style="text-align:center">“XXX”需要您的同意，才能始终访问位置</td>
</tr>
<tr>
<td style="text-align:center">日历</td>
<td style="text-align:center">NSCalendarsUsageDescription</td>
<td style="text-align:center">“XXX”需要您的同意，才能访问日历</td>
</tr>
<tr>
<td style="text-align:center">提醒事项</td>
<td style="text-align:center">NSRemindersUsageDescription</td>
<td style="text-align:center">“XXX”需要您的同意，才能访问提醒事项</td>
</tr>
<tr>
<td style="text-align:center">运动与健身</td>
<td style="text-align:center">NSMotionUsageDescription</td>
<td style="text-align:center">“XXX”需要您的同意，才能访问运动与健身</td>
</tr>
<tr>
<td style="text-align:center">健康更新</td>
<td style="text-align:center">NSHealthUpdateUsageDescription</td>
<td style="text-align:center">“XXX”需要您的同意，才能访问健康更新</td>
</tr>
<tr>
<td style="text-align:center">健康分享</td>
<td style="text-align:center">NSHealthShareUsageDescription</td>
<td style="text-align:center">“XXX”需要您的同意，才能访问健康分享</td>
</tr>
<tr>
<td style="text-align:center">蓝牙</td>
<td style="text-align:center">NSBluetoothPeripheralUsageDescription</td>
<td style="text-align:center">“XXX”需要您的同意，才能访问蓝牙</td>
</tr>
<tr>
<td style="text-align:center">媒体资料库</td>
<td style="text-align:center">NSAppleMusicUsageDescription</td>
<td style="text-align:center">“XXX”需要您的同意，才能访问媒体资料库</td>
</tr>
</tbody>
</table>
<h4 id="近场通讯NFC权限案例"><a href="#近场通讯NFC权限案例" class="headerlink" title="近场通讯NFC权限案例"></a>近场通讯NFC权限案例</h4><blockquote>
<p><a href="https://stackoverflow.com/questions/44380305/ios-11-core-nfc-any-sample-code" target="_blank" rel="noopener">iOS 11 Core NFC - any sample code?</a></p>
</blockquote>
<h4 id="ios11-地图定位权限设置"><a href="#ios11-地图定位权限设置" class="headerlink" title="ios11 地图定位权限设置"></a>ios11 地图定位权限设置</h4><p>iOS 11在定位权限设置上有更新，可以按以下方式进行设置：<br>在项目的 Info.plist 添加定位权限申请，根据业务需求，选择下列方式设置。<br>其中：<br><code>iOS 8 - iOS 10 版本：</code><br>NSLocationWhenInUseUsageDescription 表示应用在前台的时候可以搜到更新的位置信息。<br>NSLocationAlwaysUsageDescription 申请Always权限，以便应用在前台和后台（suspend 或 terminated）都可以获取到更新的位置数据。</p>
<p><code>iOS 11 版本：</code><br>NSLocationAlwaysAndWhenInUseUsageDescription 申请Always权限，以便应用在前台和后台（suspend 或 terminated）都可以获取到更新的位置数据（NSLocationWhenInUseUsageDescription 也必须有）。</p>
<p><code>iOS 8-iOS 11</code><br>如果需要同时支持在iOS8-iOS10和iOS11系统上后台定位，建议在plist文件中同时添加NSLocationWhenInUseUsageDescription、NSLocationAlwaysUsageDescription和NSLocationAlwaysAndWhenInUseUsageDescription权限申请。</p>
<hr>
<p>参考:<br><a href="https://www.imuo.com/a/943178cc983067710b47289d983da868881bea05e142bc6014324f0cb9a91d82" target="_blank" rel="noopener">1.关于刘海打理这种事儿，美团点评的iOS工程师早就有经验了，不信你看！</a><br><a href="https://www.jianshu.com/p/f5ee206c7df0" target="_blank" rel="noopener">2.iOS11、iPhone X、Xcode9 适配指南</a><br><a href="https://developer.apple.com/cn/ios/update-apps-for-iphone-x/" target="_blank" rel="noopener">3.为 iPhone X 更新您的 app。</a><br><a href="https://mp.weixin.qq.com/s/W1_0VrchCO50owhJNmJnuQ" target="_blank" rel="noopener">4.iOS 11 安全区域适配总结</a></p>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 适配 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Carthage 使用手册]]></title>
      <url>/2018/01/04/Carthage-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
      <content type="html"><![CDATA[<p><img src="/img/Carthage-使用手册/header.png" alt="header.png"></p>
<h2 id="iOS第三方框架管理"><a href="#iOS第三方框架管理" class="headerlink" title="iOS第三方框架管理"></a>iOS第三方框架管理</h2><p>高效快速的软件开发离不开一些成熟的第三方框架,我们需要一些方法把自己和别人写的代码组织起来，高效地利用，并以此为基础构建软件。这就涉及到使用和维护框架。当然我们可以简单的从<a href="https://github.com" target="_blank" rel="noopener">github</a>中找到需要的代码，download下来并手动集成到你的项目中。但这种做法费时费力，且难以维护。这个时候我们需要一套适用于iOS的第三方框架依赖管理器。</p>
<h4 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h4><p><a href="http://cocoapods.org" target="_blank" rel="noopener">CocoaPods</a> 是一个已经有五年历史的ruby程序，用于帮助获取和管理依赖框架。CocoaPods 的主要原理是框架的提供者通过编写合适的 PodSpec 文件来提供框架的基本信息，包括仓库地址，需要编译的文件，依赖等。用户使用 Podfile 文件指定想要使用的框架，CocoaPods 会创建一个新的工程来管理这些框架和它们的依赖，并把所有这些框架编译到成一个<em>静态的</em>libPod.a。然后新建一个 workspace 包含你原来的项目和这个新的框架项目，最后在原来的项目中使用这个 libPods.a。<br><a id="more"></a><br>这是一种“侵入式”的集成方式，它会修改你的项目配置和结构。</p>
<p>在实际使用过程中我们发现Cocoapods与SVN存在不兼容性，在使用SVN管理Cocoapods资源的时候需要忽略一些文件（Pods、Podfile.lock）；或者只提交Podfile文件，并在另一个工作环境中运行pod install进行配置。</p>
<h4 id="iOSUniversalLibs"><a href="#iOSUniversalLibs" class="headerlink" title="iOSUniversalLibs"></a>iOSUniversalLibs</h4><p>为了简化操作，我们将常用框架进行整合并封装进iOSUniversalLibs中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn://172.17.0.2/syun/trunk/source/code/Common/iOS/libs/iOSUniversalLibs</span><br></pre></td></tr></table></figure></p>
<p>该库包含了主要的网络请求、HUD提示、网络图片下载、下拉加载等框架，并加以维护。</p>
<p>该库解决了SVN版本管控的冲突，但无法根据具体项目配置需要的框架，且无法同步第三方框架版本，需要人工维护，存在很大的局限性。</p>
<h4 id="Carthage"><a href="#Carthage" class="headerlink" title="Carthage"></a>Carthage</h4><p><a href="https://github.com/Carthage/Carthage" target="_blank" rel="noopener">Carthage</a> 是在 Cocoa Touch Framework 和 Swift 发布后出现的专门针对 Framework 进行的包管理工具。</p>
<p>Carthage 相比 CocoaPods，采用的是完全不同的一条道路。Carthage 只支持动态框架，它仅负责将项目 clone 到本地并将对应的 Cocoa Framework target 进行构建。之后你需要自行将构建好的 framework 添加到项目中。和 CocoaPods 需要提交和维护框架信息不同，Carthage 是去中心化的 它直接从 git 仓库获取项目，而不需要依靠 podspec 类似的文件来管理。</p>
<h2 id="安装Carthage"><a href="#安装Carthage" class="headerlink" title="安装Carthage"></a>安装Carthage</h2><p>Carthage提供了三种安装方法，这里推荐使用<a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>来进行安装:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$brew update</span><br><span class="line">$brew install carthage</span><br></pre></td></tr></table></figure></p>
<p>并通过<code>$brew update</code>来更新carthage版本。</p>
<p>当然你也可以 <a href="https://github.com/Carthage/Carthage/releases" target="_blank" rel="noopener">下载最新版本 .pkg 包</a>，双击安装到你的Mac电脑里，但是当你需要更新carthage版本时需要重新下载安装包安装，非常繁琐。</p>
<p>当你完成安装之后，你可以通过<code>$carthage version</code>来检查carthage是否正确安装。当前最新版本号为0.22.0。</p>
<h2 id="添加框架到应用程序"><a href="#添加框架到应用程序" class="headerlink" title="添加框架到应用程序"></a>添加框架到应用程序</h2><h4 id="创建Cartfile文件"><a href="#创建Cartfile文件" class="headerlink" title="创建Cartfile文件"></a>创建Cartfile文件</h4><p>在开始使用Carthage时，我们需要为应用程序创建一个<code>Cartfile</code>的工程描述文件，这个文件可以被标准的OGDL（<a href="http://ogdl.org/" target="_blank" rel="noopener">Ordered Graph Data Language</a>）工具编辑，我们可以使用xcode或者vim等文字编辑工具打开，这里需要注意的是，系统默认的打开工具是系统自带的文字编辑工具(TextEdit)，该工具具有的智能引号功能会自动将<code>&#39;</code>替换成<code>’</code>，导致Carthage无法识别，在编辑时需要在文本编辑工具的 编辑-&gt;替换 中将智能引号功能取消。 Cartfile是一个描述工程依赖第三方的文件，每个依赖描述包括了所依赖的第三方框架的仓库地址，框架名称以及版本号等信息，Carthage其实等价于Cocoapods里的Podfile。</p>
<p>在创建Cartfile的时候你需要打开终端并通过 <strong>cd</strong> 命令行进入你的应用项目根文件路径（包含项目工程 <strong>.xcodeproj</strong> 文件的文件夹）下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cd ~/Path/To/Starter/Project</span><br></pre></td></tr></table></figure></p>
<p>使用<strong>touch</strong>命令创建一个空的Cartfile:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$touch Cartfile</span><br></pre></td></tr></table></figure></p>
<p>接着你可以通过xcode来打开Cartfile文件进行编辑:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open -a Xcode Cartfile</span><br></pre></td></tr></table></figure></p>
<p>我们可以尝试在Cartfile中添加下列内容并保存:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">github &quot;https://github.com/AFNetworking/AFNetworking.git&quot; ~&gt; 3.0</span><br><span class="line">github &quot;ReactiveCocoa/ReactiveCocoa&quot; &gt;= 2.3.1</span><br></pre></td></tr></table></figure></p>
<p>在上面两句依赖语句中,分别声明了两个框架,可以看出依赖语句是由框架源以及版本号两个主要部分组成的。对于从github上依赖的库,我们在声明了<code>github</code>关键字之后,接上依赖库的github地址便可，当然我们也可以简写这个地址，将其简单的描述成<code>Username/Projectname</code>的形式。而框架版本的描述规则如下：</p>
<ol>
<li><code>&gt;= 1.0</code>代表使用1.0或更高版本</li>
<li><code>~&gt; 1.0</code>代表使用1.0以上但是低于2.0的版本</li>
<li><code>== 1.0</code>代表只能使用指定的1.0版本</li>
</ol>
<p>关于cartfile的编写规则,具体可以参考<a href="https://github.com/Carthage/Carthage/blob/master/Documentation/Artifacts.md#cartfile" target="_blank" rel="noopener">这里</a>。</p>
<h4 id="构建依赖"><a href="#构建依赖" class="headerlink" title="构建依赖"></a>构建依赖</h4><p>cartfile创建完成之后保存并退出，回到终端并执行下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">carthage update --platform iOS</span><br></pre></td></tr></table></figure></p>
<p><code>--platform iOS</code>会让Carthage编译的框架只支持iOS平台,如果你不声明的话,Carthage将会默认为你编译全平台的框架。</p>
<p>执行完update命令，carthage会自动下载和编译所需的第三方框架，当命令执行完成，在你的项目文件夹中会创建一个名为Carthage的文件夹，在~/Carthage/Build/iOS中可以找到编译好的.framework框架。在~/Carthage/Checkouts中则可以找到框架的源码。</p>
<h4 id="在项目中添加框架"><a href="#在项目中添加框架" class="headerlink" title="在项目中添加框架"></a>在项目中添加框架</h4><p>打开项目，点击project，选择target-&gt;General，将需要的framework文件拖到Linken Frameworks and Libraries中:</p>
<p><img src="/img/Carthage-使用手册/carthage-settings.gif" alt="carthage-settings.gif"></p>
<p>在target-&gt;Build Phases设置项中点击 ==+== 按钮并选择 ==New Run Script Pahse== :</p>
<p><img src="/img/Carthage-使用手册/newScript.png" alt="newScript.png"></p>
<p>在run script中加入如下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/Carthage copy-frameworks</span><br></pre></td></tr></table></figure></p>
<p>同时在下方的==Input Files==中为每个framework添加地址:</p>
<p><img src="/img/Carthage-使用手册/configScript.png" alt="configScript.png"></p>
<p>这些是为了解决<a href="http://www.openradar.me/radar?id=6409498411401216" target="_blank" rel="noopener">App Store submission bug</a>的方法。</p>
<p>做完这些，你的项目就已经配置好了，现在你已经可以在项目中使用 ==#import &lt;Framework/header.h&gt;== 来调用框架提供的方法了。</p>
<h4 id="更新框架"><a href="#更新框架" class="headerlink" title="更新框架"></a>更新框架</h4><p>如果需要更新框架版本或者添加新的框架,只需打开修改cartfile，保存并重新运行<code>carthage update --platform iOS</code>，carthage将会重新checkout 并编译。</p>
<h2 id="创建框架并支持到Carthage"><a href="#创建框架并支持到Carthage" class="headerlink" title="创建框架并支持到Carthage"></a>创建框架并支持到Carthage</h2><p>由于carthage是iOS8之后才出现的依赖工具，现阶段支持的第三方框架有限，同时，为了方便开发，我们内部也封装了一些常用框架，这个时候，我们可以自己将需要的框架配置支持carthage。</p>
<h4 id="配置Xcode-Project"><a href="#配置Xcode-Project" class="headerlink" title="配置Xcode Project"></a>配置Xcode Project</h4><p>以iOS时间工具库<a href="https://github.com/MatthewYork/DateTools" target="_blank" rel="noopener">DateTools</a>为例，该库提供了丰富的时间日期操作方法，可以大大减少开发时时间计算及时间格式转换等功能代码量，但该库并不支持Carthage。现在我们将其进行支持carthage配置。<br>首先，将DateTools仓库Fork到<a href="https://github.com/GosuncnMobile" target="_blank" rel="noopener">部门github账号</a>下，clone源码到本地。</p>
<p>打开Xcode，选择File-&gt;New-&gt;Project(快捷键==shift+command+N==),选择iOS-&gt;Farmework &amp; Library 选项下的==Cocoa Touch Library==,点击==Next==按钮,进入Product option界面,填写基本的工程信息。</p>
<p><img src="/img/Carthage-使用手册/settingProject.png" alt="settingProject.png"></p>
<p>工程创建完毕后，点开Xcode左上角==scheme==选项并选择==Manage Schemes==</p>
<p><img src="/img/Carthage-使用手册/manageSchemes.png" alt="manageSchemes.png"></p>
<p>将需要构建的==scheme==勾选==Shared==</p>
<p><img src="/img/Carthage-使用手册/shareSchemes.png" alt="shareSchemes.png"></p>
<p>这样Carthage就可以发现该工程。</p>
<h4 id="尝试编译工程"><a href="#尝试编译工程" class="headerlink" title="尝试编译工程"></a>尝试编译工程</h4><p>在进行完上述操作后，你可以尝试将工程编译成framework来测试一下框架能否正确运行。</p>
<p>打开终端，进入到项目文件夹，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$carthage build --no-skip-current</span><br></pre></td></tr></table></figure></p>
<p>命令运行成功后，在项目文件目录中会多一个Carthage的文件夹，在<strong>Carthage-&gt;Build-&gt;iOS</strong>下能找到编译完成的<strong>DateTools.framework</strong>。你可以创建一个新工程并将该framework导入测试工程能否正确运行。<br>如果<code>carhtage build --no-skip-current</code>命令无法成功编译，尝试使用<code>xcodebuild -scheme SCHEME -workspace WORKSPACE build</code> 或 <code>xcodebuild -scheme SCHEME -project PROJECT build</code>命令，看是否出现同样错误，这可以为解决问题提供足够的信息。</p>
<h4 id="提交到GitHub仓库"><a href="#提交到GitHub仓库" class="headerlink" title="提交到GitHub仓库"></a>提交到GitHub仓库</h4><p>如果你的测试工程编译通过了，那么证明你的框架已经搭建成功了，这时候只需将工程提交到github仓库，框架就将支持carthage。</p>
<p>在前面编写cartfile的时候我们知道，版本号是carthage依赖的重要信息，事实上Carthage是通过搜索发布到仓库中的==tag==来决定framework的哪个版本是可用的，并会试着将每个==tag==翻译成 <a href="http://semver.org/lang/zh-CN/" target="_blank" rel="noopener">semantic version</a>（语义化版本）。比如，==tag v1.2==，语义版本是==1.2.0==。没有数字版本号的==tag==，或者在数字版本后跟着其他字符的==tag==（比如：==1.2-alpha-1==）这种版本号目前carthage不提供支持。</p>
<p>所以在提交工程后，还需要为新提交的内容打上==tag==。针对DateTools这种第三方框架，因为之前作者已为稳定的版本打上==tag==，为了保持版本号的统一，可以先将原作者的==tag==删除为新提交的工程打上相同的==tag==。</p>
<h4 id="将预构建的frameworks归档到zip文件"><a href="#将预构建的frameworks归档到zip文件" class="headerlink" title="将预构建的frameworks归档到zip文件"></a>将预构建的frameworks归档到zip文件</h4><p>GtiHub提供了<em>Release</em>功能，如果使用了该功能，在依赖框架时，Carthage会自动使用预构建的framework，而不需要根据代码重新构建。</p>
<p>Carthage提供了framework的构建打包功能，打开工程文件夹，运行下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$carthage build --no-skip-current</span><br><span class="line">$carthage archive YourFrameworkName</span><br></pre></td></tr></table></figure></p>
<p>命令执行完成后,你将在工程文件夹中找到一个工程框架的.zip压缩文件。在 github 工程 release 界面，根据对应的版本号，将该zip文件上传上去。</p>
<p>至此，使框架支持Carthage的工作就已经完成了，只要在cartfile上注明依赖，该框架就可通过carthage集成到需要的项目中。</p>
<p>如果需要搭建可支持多平台的框架，可以参考 <a href="http://basememara.com/creating-cross-platform-swift-frameworks-ios-watchos-tvos-via-carthage-cocoapods/" target="_blank" rel="noopener">Creating Cross-Platform Swift Frameworks for iOS, watchOS, and tvOS via Carthage and CocoaPods</a> 这篇文章。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://github.com/Carthage/Carthage/blob/master/README.md" target="_blank" rel="noopener">Carthage README</a></li>
<li><a href="https://www.raywenderlich.com/109330/carthage-tutorial-getting-started" target="_blank" rel="noopener">Carthage Turorial:Getting Started</a></li>
<li><a href="https://robots.thoughtbot.com/creating-your-first-ios-framework" target="_blank" rel="noopener">Creating your first iOS Framework</a></li>
<li><a href="http://devtian.me/2015/08/11/translate-carthage-readme/" target="_blank" rel="noopener">(译)Carthage 使用说明</a></li>
<li><a href="http://www.jianshu.com/p/bf263c596538" target="_blank" rel="noopener">Carthage使用心得-让自己的项目支持Carthage</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android编译时注解]]></title>
      <url>/2017/12/27/Android%E7%BC%96%E8%AF%91%E6%97%B6%E6%B3%A8%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="Android编译时注解"><a href="#Android编译时注解" class="headerlink" title="Android编译时注解"></a>Android编译时注解</h1><p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>相信大家经常都使用到注解，如果使用过AndroidAnnotations,Dagger2,EventBus,RxJava,BufferKnife等开源项目，对注解应该更为深刻，这些项目的原理基本都是基于编译时注解动态生成代码，效果等同于手写代码，因此相对反射来说性能基本无影响。</p>
<p>另外，已经实现了<a href="https://github.com/android-coding-well/AwesomeTool" target="_blank" rel="noopener">注解轻松实现线程切换开源项目</a>，欢迎fork&amp;star.</p>
<h2 id="了解注解"><a href="#了解注解" class="headerlink" title="了解注解"></a>了解注解</h2><h3 id="注解的概念"><a href="#注解的概念" class="headerlink" title="注解的概念"></a>注解的概念</h3><p>注解（Annotation），也叫元数据（Metadata），是Java5的新特性，JDK5引入了Metadata很容易的就能够调用Annotations。注解与类、接口、枚举在同一个层次，并可以应用于包、类型、构造方法、方法、成员变量、参数、本地变量的声明中，用来对这些元素进行说明注释。<br><a id="more"></a></p>
<h3 id="注解的语法与定义"><a href="#注解的语法与定义" class="headerlink" title="注解的语法与定义"></a>注解的语法与定义</h3></blockquote>
<ol>
<li>以@interface关键字定义</li>
<li>注解可以包含成员，成员以无参数的方法的形式被声明，其方法名和返回值定义了该成员的名字和类型。</li>
<li>成员赋值是通过@Annotation(name=value)的形式。</li>
<li>注解需要标明注解的生命周期，注解的修饰目标等信息，这些信息是通过元注解实现。</li>
</ol>
<p>以 java.lang.annotation 中定义的 Target 注解为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(value = &#123; ElementType.ANNOTATION_TYPE &#125; )</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>源码分析如下：<br>第一：元注解@Retention，成员value的值为RetentionPolicy.RUNTIME。<br>第二：元注解@Target，成员value是个数组，用{}形式赋值，值为ElementType.ANNOTATION_TYPE<br>第三：成员名称为value，类型为ElementType[]<br>另外，需要注意一下，如果成员名称是value，在赋值过程中可以简写。如果成员类型为数组，但是只赋值一个元素，则也可以简写。如上面的简写形式为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="注解的分类"><a href="#注解的分类" class="headerlink" title="注解的分类"></a>注解的分类</h3><p> <strong>1</strong> 基本内置注解，是指Java自带的几个Annotation，如@Override、Deprecated、@SuppressWarnings等；<br> <strong>2</strong> 元注解（meta-annotation），是指负责注解其他注解的注解，JDK 1.5及以后版本定义了4个标准的元注解类型，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span></span><br><span class="line"><span class="meta">@Retention</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br></pre></td></tr></table></figure></p>
<p> <strong>3</strong> 自定义注解，根据需要可以自定义注解，自定义注解需要用到上面的meta-annotation</p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul>
<li>Java定义了4个标准的元注解（ <span style="color:#F00">java8之后新增了<strong>@Repeatable</strong>元注解</span>）：</li>
<li><strong>@Documented</strong>：标记注解，注解表明这个注解应该被 javadoc工具记录. 默认情况下,javadoc是不包括注解的. 但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理, 所以注解类型信息也会被包括在生成的文档中。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Documented &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<ul>
<li><strong>@Inherited</strong>：标记注解，允许子类继承父类的注解，此注解理解有难度，可以参考<a href="http://blog.csdn.net/lemon89/article/details/47836783" target="_blank" rel="noopener">这里</a>，总的来说就是子类在继承父类时如果父类上的注解有此@Inherited标记，那么子类就能把父类的这个注解继承下来，如果没有@Inherited标记，那么子类在继承父类之后并没有继承父类的注解（不知道有没有说明白了，不明白就还是点进链接去看下吧）。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Inherited &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<ul>
<li><strong>@Retention</strong>：指Annotation被保留的时间长短，标明注解的生命周期<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>注解需要标明注解的生命周期，这些信息是通过元注解 @Retention 实现，注解的值是 enum 类型的 RetentionPolicy，包括以下几种情况：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃.</span></span><br><span class="line"><span class="comment">     * 这意味着注解仅存在于编译器处理期间，编译器处理完之后，该注解就没用了，在class文件找不到了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期.</span></span><br><span class="line"><span class="comment">     * 简单来说就是你在class文件中还能看到注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在，</span></span><br><span class="line"><span class="comment">     * 保存到class对象中，可以通过反射来获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<ul>
<li><strong>@Target</strong>：标明注解的修饰目标（ <span style="color:#F00">java8为ElementType枚举增加了<strong>TYPE_PARAMETER</strong>、<strong>TYPE_USE</strong>两个枚举值</span>）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ElementType取值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line">    <span class="comment">/** 类、接口（包括注解类型）或枚举 */</span></span><br><span class="line">    TYPE,</span><br><span class="line">    <span class="comment">/** field属性，也包括enum常量使用的注解 */</span></span><br><span class="line">    FIELD,</span><br><span class="line">    <span class="comment">/** 方法 */</span></span><br><span class="line">    METHOD,</span><br><span class="line">    <span class="comment">/** 参数 */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line">    <span class="comment">/** 构造函数 */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line">    <span class="comment">/** 局部变量 */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line">    <span class="comment">/** 注解上使用的元注解 */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line">    <span class="comment">/** 包 */</span></span><br><span class="line">    PACKAGE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="注解处理器-Annotation-Processor"><a href="#注解处理器-Annotation-Processor" class="headerlink" title="注解处理器(Annotation Processor)"></a>注解处理器(Annotation Processor)</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>注解处理器是javac的一个工具，它用来在编译时扫描和处理注解（Annotation）。你可以自定义注解，并注册到相应的注解处理器，由注解处理器来处理你的注解。一个注解的注解处理器，以Java代码（或者编译过的字节码）作为输入，生成文件（通常是.java文件）作为输出。这些生成的Java代码是在生成的.java文件中，所以你不能修改已经存在的Java类，例如向已有的类中添加方法。这些生成的Java文件，会同其他普通的手动编写的Java源代码一样被javac编译。</p>
<p>简单来说，在源代码编译阶段，通过注解处理器，将标记了注解的类、方法等作为输入内容，经过注解处理器进行处理，产生需要的java代码。</p>
<p>Android Gradle插件2.2版本发布后，Android 官方提供了annotationProcessor来代替android-apt，annotationProcessor支持 javac 和 jack 编译方式，而android-apt只支持 javac 编译方式。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>直接在Module中使用，比之前Android-apt使用方式更加简单。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	        compile &apos;com.github.huweijian5:AwesomeTool:latest_version&apos;</span><br><span class="line">		annotationProcessor &apos;com.github.huweijian5:AwesomeTool-compiler:latest_version&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h2 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h2><blockquote>
<p>接下来以本人写的一个注解实现线程切换的项目为例，讲解下编译时注解的编码过程。</p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>本项目主要分为三个Module，分别为lib_api，lib_annotation，lib_compiler。<br>其中lib_api主要存放供外界使用的接口，是对外开放的<br>lib_annotation里指定了自定义注解的定义<br>lib_compiler里实现注解处理器，是本项目的核心</p>
</blockquote>
<ul>
<li><p>项目目录结构如下图：<br><img src="http://img.blog.csdn.net/20171227091018608?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3ZWlqaWFuNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
<li><p>依赖关系图如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app-&gt;lib_api:dependence</span><br><span class="line">lib_api-&gt;lib_annotation: dependence</span><br><span class="line">lib_compiler-&gt;lib_annnotaion: dependence</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>值得注意的是，lib_annotation和lib_compiler都是java工程（apply plugin: ‘java’），而lib_api是android工程（apply plugin: ‘com.android.library’）</p>
<h3 id="lib-annotation"><a href="#lib-annotation" class="headerlink" title="lib_annotation"></a>lib_annotation</h3><p>此Module主要实现自定义的注解定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注入对象实例</span></span><br><span class="line"><span class="comment"> * Created by HWJ on 2017/3/12.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InjectObject &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程优先级-20~19,-20代表优先级最高，详见android.os.Process,默认为THREAD_PRIORITY_DEFAULT(0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后台线程注解</span></span><br><span class="line"><span class="comment"> * Created by HWJ on 2017/3/12.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WorkInBackground &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 1. UI线程注解</span></span><br><span class="line"><span class="comment"> 2. Created by HWJ on 2017/3/12.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WorkInMainThread &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lib-api"><a href="#lib-api" class="headerlink" title="lib_api"></a>lib_api</h3><ul>
<li>定义接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IObjectInjector</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>利用反射进行注入实例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取生成类全称</span></span><br><span class="line">        Class&lt;?&gt; clazz = target.getClass();</span><br><span class="line">        String proxyClassFullName = clazz.getName() + ConstantValue.SUFFIX;</span><br><span class="line">        Class&lt;?&gt; proxyClazz = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//反射生成类实例对象并进行注入</span></span><br><span class="line">            proxyClazz = Class.forName(proxyClassFullName);</span><br><span class="line">            IObjectInjector objectInjector = (IObjectInjector) proxyClazz.newInstance();</span><br><span class="line">            objectInjector.inject(target);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"注入失败："</span>+e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="lib-compiler"><a href="#lib-compiler" class="headerlink" title="lib_compiler"></a>lib_compiler</h3><blockquote>
<p>lib_compiler中实现注解处理器，是项目的核心，本项目是使用Handler和HandlerThread实现线程切换，对于HandlerThread线程切换的使用网络文章已经有很多，本文不再赘述。</p>
</blockquote>
<p><strong>1 添加以下依赖：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">//auto-service库可以帮我们去生成META-INF等信息</span><br><span class="line">compile &apos;com.google.auto.service:auto-service:1.0-rc4&apos;</span><br><span class="line">//用于生成源代码</span><br><span class="line">compile &apos;com.squareup:javapoet:1.9.0&apos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//只有android N支持java8，如果你写1.8之后，强制要你使用buildToolsVersion为24.0.0</span><br><span class="line">sourceCompatibility = &quot;1.7&quot;</span><br><span class="line">targetCompatibility = &quot;1.7&quot;</span><br><span class="line"></span><br><span class="line">.</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意此Module为java工程，而不是android工程，如果弄错了就会报找不到类AbstractProcessor的错误</p>
</blockquote>
<hr>
<p><strong>2 继承AbstractProcessor,并实现方法init,getSupportedAnnotationTypes,getSupportedSourceVersion,process四个方法即可，参考代码如下：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoService</span>(Processor.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwesomeToolProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"AwesomeToolProcessor"</span>;</span><br><span class="line">    <span class="keyword">private</span> Filer mFileUtils;<span class="comment">//跟文件相关的辅助类，生成JavaSourceCode</span></span><br><span class="line">    <span class="keyword">private</span> Elements elementUtils;<span class="comment">//跟元素相关的辅助类，帮助我们去获取一些元素相关的信息</span></span><br><span class="line">    <span class="keyword">private</span> Messager messager;<span class="comment">//跟日志相关的辅助类</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, AwesomeToolProxyInfo&gt; proxyInfoMap = <span class="keyword">new</span> HashMap&lt;String, AwesomeToolProxyInfo&gt;();<span class="comment">//key为注解所在类的全名</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">        messager = processingEnv.getMessager();</span><br><span class="line">        elementUtils = processingEnv.getElementUtils();</span><br><span class="line">        mFileUtils=processingEnv.getFiler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持的注解类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashSet&lt;String&gt; supportTypes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        supportTypes.add(InjectObject.class.getCanonicalName());</span><br><span class="line">        supportTypes.add(WorkInBackground.class.getCanonicalName());</span><br><span class="line">        supportTypes.add(WorkInMainThread.class.getCanonicalName());</span><br><span class="line">        <span class="keyword">return</span> supportTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解处理器支持到的JAVA版本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printMessage(<span class="string">"SupportedSourceVersion=%s"</span>,SourceVersion.latestSupported().name());</span><br><span class="line">        <span class="keyword">return</span> SourceVersion.latestSupported();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        printMessage(<span class="string">"process:annotations size=%d"</span>, annotations.size());</span><br><span class="line">        proxyInfoMap.clear();</span><br><span class="line">        handleInjectObjectAnnotation(roundEnv);</span><br><span class="line">        handleWorkInBackgroundAnnotation(roundEnv);</span><br><span class="line">        handleWorkInMainThreadAnnotation(roundEnv);</span><br><span class="line"></span><br><span class="line">        printMessage(<span class="string">"AwesomeToolProxyInfo Map size=%d"</span>, proxyInfoMap.size());</span><br><span class="line"></span><br><span class="line">        generateSourceFiles();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//如果返回true,当有两个注解作用在同一方法上，那么第一个处理完了之后就不会再处理第二个</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注解@AutoService(Processor.class)可以自动帮我们处理一些工作，简化代码</p>
<p>init中可以获得Messager用来打印信息，打印的信息会显示在AndroidStudio的Gradle Console窗口<br>同时也可以获得Elements，用来获取元素的相关信息，还有Filer,可以用来生成代码</p>
<p>getSupportedAnnotationTypes里需要返回支持的注解类型，就是lib_annotation中定义的注解</p>
<p>getSupportedSourceVersion为注解处理器支持到的java版本</p>
<p>process里处理注解元素作用的类方法等，根据自己的业务逻辑处理并生成相应代码</p>
</blockquote>
<hr>
<p><strong>3 处理注解</strong></p>
<blockquote>
<p>通过RoundEnvironment.getElementsAnnotatedWith()可以获得注解所在的方法类等，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;? extends Element&gt; elesWithBind = roundEnv.getElementsAnnotatedWith(WorkInMainThread.class);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>其中Element的类型及说明如下：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ExecutableElement</td>
<td>Represents a method, constructor, or initializer (static or instance) of a class or interface, including annotation type elements.</td>
</tr>
<tr>
<td style="text-align:left">VariableElement</td>
<td>Represents a field, {@code enum} constant, method or constructor parameter, local variable, resource variable, or exception parameter.</td>
</tr>
<tr>
<td style="text-align:left">PackageElement</td>
<td>Represents a package program element.  Provides access to information about the package and its members.</td>
</tr>
</tbody>
</table>
<ul>
<li>获取方法参数,参考代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (VariableElement variableElement : executableElement.getParameters()) &#123;</span><br><span class="line">               System.out.println(<span class="string">"参数类型及名称："</span> + variableElement.asType() + <span class="string">","</span> + variableElement.getSimpleName());</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p><strong>4 生成代码</strong></p>
<blockquote>
<p>生成代码的方式可以通过手动拼接字符串，也可以通过开源库javapoet实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    JavaFileObject jfo = processingEnv.getFiler().createSourceFile(</span><br><span class="line">            proxyInfo.getProxyClassFullName(),<span class="comment">//类名全称</span></span><br><span class="line">            proxyInfo.getTypeElement());<span class="comment">//类元素</span></span><br><span class="line">    Writer writer = jfo.openWriter();</span><br><span class="line">    writer.write(proxyInfo.generateJavaCode());</span><br><span class="line">    writer.flush();</span><br><span class="line">    writer.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    error(proxyInfo.getTypeElement(),</span><br><span class="line">            <span class="string">"Unable to write injector for type %s: %s"</span>,</span><br><span class="line">            proxyInfo.getTypeElement(), e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<blockquote>
<p>至此已经走完了编译时注解的整个流程，最后贴下生成的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Generated code. Do not modify!</span></span><br><span class="line"><span class="comment">//自动生成代码，请勿修改！</span></span><br><span class="line"><span class="keyword">package</span> com.junmeng.aad;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.HandlerThread;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.junmeng.api.inter.IObjectInjector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlankFragmentHelper</span> <span class="keyword">implements</span> <span class="title">IObjectInjector</span>&lt;<span class="title">BlankFragment</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_NEEDWORKINTHREAD = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_NEEDWORKINMAINTHREAD = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> Handler mainHandler;</span><br><span class="line">    <span class="keyword">private</span> Handler workHandler;</span><br><span class="line">    <span class="keyword">private</span> HandlerThread handlerThread;</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;BlankFragment&gt; target;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(<span class="keyword">final</span> BlankFragment target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target.blankFragmentHelper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target.blankFragmentHelper.quit();</span><br><span class="line">        &#125;</span><br><span class="line">        target.blankFragmentHelper = <span class="keyword">new</span> BlankFragmentHelper();</span><br><span class="line">        target.blankFragmentHelper.init(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> BlankFragment target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = <span class="keyword">new</span> WeakReference&lt;BlankFragment&gt;(target);</span><br><span class="line">        handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"thread_BlankFragmentHelper"</span>, -<span class="number">16</span>);</span><br><span class="line">        handlerThread.start();</span><br><span class="line">        mainHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                List&lt;Object&gt; params;</span><br><span class="line">                <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                    <span class="keyword">case</span> MESSAGE_NEEDWORKINMAINTHREAD:</span><br><span class="line">                        params = (List&lt;Object&gt;) msg.obj;</span><br><span class="line">                        target.needWorkInMainThread();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        workHandler = <span class="keyword">new</span> Handler(handlerThread.getLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                List&lt;Object&gt; params;</span><br><span class="line">                <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                    <span class="keyword">case</span> MESSAGE_NEEDWORKINTHREAD:</span><br><span class="line">                        params = (List&lt;Object&gt;) msg.obj;</span><br><span class="line">                        target.needWorkInThread((java.lang.String) params.get(<span class="number">0</span>), (<span class="keyword">int</span>) params.get(<span class="number">1</span>), (<span class="keyword">double</span>) params.get(<span class="number">2</span>), (com.junmeng.aad.Test) params.get(<span class="number">3</span>));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">needWorkInThread</span><span class="params">(java.lang.String str, <span class="keyword">int</span> i, <span class="keyword">double</span> d, com.junmeng.aad.Test test)</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; params = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        params.add(str);</span><br><span class="line">        params.add(i);</span><br><span class="line">        params.add(d);</span><br><span class="line">        params.add(test);</span><br><span class="line">        workHandler.sendMessage(workHandler.obtainMessage(MESSAGE_NEEDWORKINTHREAD, params));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">needWorkInMainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; params = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        mainHandler.sendMessage(mainHandler.obtainMessage(MESSAGE_NEEDWORKINMAINTHREAD, params));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在不用时务必调用此方法，防止内存泄漏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handlerThread != <span class="keyword">null</span> &amp;&amp; handlerThread.isAlive()) &#123;</span><br><span class="line">            handlerThread.quitSafely();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，说明下google的auto-service实际上会帮助我们生成jar包并添加META-INF信息，如下图<br><img src="http://img.blog.csdn.net/20171227112008839?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3ZWlqaWFuNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="如有错误之处请指正，谢谢。"><a href="#如有错误之处请指正，谢谢。" class="headerlink" title="如有错误之处请指正，谢谢。"></a>如有错误之处请指正，谢谢。</h1><h1 id="待解决的关键问题"><a href="#待解决的关键问题" class="headerlink" title="待解决的关键问题"></a>待解决的关键问题</h1><ul>
<li>按照上面的实现只能在build的时候才能生成代码，有没有即时生成的技术呢？还没找到答案。<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1></li>
<li><a href="http://blog.csdn.net/wzgiceman/article/details/54580745" target="_blank" rel="noopener">http://blog.csdn.net/wzgiceman/article/details/54580745</a></li>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/43452969" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791/article/details/43452969</a></li>
<li><a href="http://blog.csdn.net/github_35180164/article/details/52107204" target="_blank" rel="noopener">http://blog.csdn.net/github_35180164/article/details/52107204</a></li>
<li><a href="https://www.jianshu.com/p/28edf5352b63" target="_blank" rel="noopener">https://www.jianshu.com/p/28edf5352b63</a></li>
</ul>
</blockquote>
]]></content>
      
        <categories>
            
            <category> android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> android </tag>
            
            <tag> 注解 </tag>
            
            <tag> 线程切换 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android statusBar 开发问题汇总]]></title>
      <url>/2017/12/25/Android-statusBar-%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<h3 id="Android-statusBar-开发问题汇总"><a href="#Android-statusBar-开发问题汇总" class="headerlink" title="Android statusBar 开发问题汇总"></a>Android statusBar 开发问题汇总</h3><h4 id="适配有虚拟按键的手机，比如华为荣耀系列手机"><a href="#适配有虚拟按键的手机，比如华为荣耀系列手机" class="headerlink" title="适配有虚拟按键的手机，比如华为荣耀系列手机"></a>适配有虚拟按键的手机，比如华为荣耀系列手机</h4><p>   手机开屏出现白屏和黑屏的解决方法是在开屏的Activity中进行设置自定义的主题：<br>   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 防止欢迎页白屏或者黑屏，设置图片或者渐变drawable --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme.SplashTheme"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">       <span class="comment">&lt;!--最先呈现给用户查看--&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowBackground"</span>&gt;</span>@drawable/shape_bg_start_page<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined">       </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>   在其他手机上如上诉代码设置即可，但在华为手机上会发现虚拟按钮及顶部statusBar跟自己设置的主题颜色很不协调。其颜色<br>   默认为 <strong> 黑底白字 </strong>。<br>   可以添加如下代码进行设置：</p>
   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 防止欢迎页白屏或者黑屏，设置图片 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme.SplashTheme"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!--最先呈现给用户查看--&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowBackground"</span>&gt;</span>@drawable/shape_bg_start_page<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!--考虑华为手机虚拟按键的显示--&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowTranslucentNavigation"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowTranslucentStatus"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>最后得到如图<br><img src="/img/AndroidstatusBar开发问题汇总/华为1.jpg" alt="华为1.jpg">    <img src="/img/AndroidstatusBar开发问题汇总/华为2.jpg" alt="华为2.jpg"></p>
<p><img src="/img/AndroidstatusBar开发问题汇总/华为3.jpg" alt="华为3.jpg"></p>
<ul>
<li>可从图片上观察到虚拟按键和statuBar的背景色和自定义的主题色进行了很好的== 拉伸过渡==<h4 id="设置statusBar颜色-适配4-4以上系统"><a href="#设置statusBar颜色-适配4-4以上系统" class="headerlink" title="设置statusBar颜色 适配4.4以上系统"></a>设置statusBar颜色 适配4.4以上系统</h4>但实现上述的效果图，可不仅仅依靠上面两行代码，上面两行代码只是针对开屏页进行了设置。<strong> 后续界面的实现请看下面代码： </strong><br>为了考虑不同手机的兼容性及不同api（api&gt;=19 即adnroid 4.4版本）,不同手机版本的statusBar的高度各有不同，所以按如下步骤进行处理：</li>
</ul>
<ul>
<li><p><strong> 第一步：获取statusbar的高度</strong><br>参考如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取状态栏高度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 状态栏高度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getStatusBarHeight</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> resourceId = context.getResources().getIdentifier(<span class="string">"status_bar_height"</span>, <span class="string">"dimen"</span>, <span class="string">"android"</span>);</span><br><span class="line">    <span class="keyword">if</span> (resourceId &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        result = context.getResources().getDimensionPixelSize(resourceId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上工具类方法可从 <a href="https://github.com/GosuncnMobile/BaseLibrary/blob/master/util/src/main/java/com/gosuncn/core/util/view/StatusBarUtils.java" target="_blank" rel="noopener">CommonUtil库</a>进行获取。</p>
</li>
<li><p><strong> 第二步：创建一个和statusBar高度一致的颜色块</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成一个和状态栏大小相同的矩形条</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> activity 需要设置的activity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> color    状态栏颜色值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 状态栏矩形条</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> View <span class="title">createStatusBarView</span><span class="params">(Activity activity, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得状态栏高度</span></span><br><span class="line"><span class="comment">//        int resourceId = activity.getResources().getIdentifier("status_bar_height", "dimen", "android");</span></span><br><span class="line"><span class="comment">//        int statusBarHeight = activity.getResources().getDimensionPixelSize(resourceId);</span></span><br><span class="line">        <span class="keyword">int</span> statusBarHeight = StatusBarUtils.getStatusBarHeight(activity);</span><br><span class="line">        Log.e(TAG, <span class="string">"createStatusView: statusBarHeight = "</span> + statusBarHeight);</span><br><span class="line">        <span class="comment">// 绘制一个和状态栏一样高的矩形</span></span><br><span class="line">        View statusView = <span class="keyword">new</span> View(activity);</span><br><span class="line">        LinearLayout.LayoutParams params = <span class="keyword">new</span> LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">                statusBarHeight);</span><br><span class="line">        statusView.setLayoutParams(params);</span><br><span class="line">        statusView.setBackgroundColor(color);</span><br><span class="line">        <span class="keyword">return</span> statusView;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong> 第三步：设置statusBar透明，添加自定义statusBar 颜色 </strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使状态栏透明</span></span><br><span class="line"><span class="meta">@TargetApi</span>(Build.VERSION_CODES.KITKAT)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transparentStatusBar</span><span class="params">(Activity activity, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;<span class="comment">//4.4 全透明状态栏</span></span><br><span class="line">        <span class="comment">//  这个属性4.4算是全透明（有的机子是过渡形式的透明），5.0则是半透明，某些手机则是全透明。</span></span><br><span class="line">        activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">        activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;<span class="comment">//5.0 全透明实现</span></span><br><span class="line">        Window window = activity.getWindow();</span><br><span class="line">        <span class="comment">//// 因为EMUI3.1系统与这种沉浸式方案API有点冲突，会没有沉浸式效果。</span></span><br><span class="line">        <span class="comment">// 所以这里加了判断，EMUI3.1系统不清除FLAG_TRANSLUCENT_STATUS</span></span><br><span class="line">        <span class="keyword">if</span> (!isEMUI3_1()) &#123;</span><br><span class="line">            window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">        &#125;</span><br><span class="line">        window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span><br><span class="line">        window.setStatusBarColor(Color.TRANSPARENT);</span><br><span class="line">        window.setNavigationBarColor(Color.TRANSPARENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Log.e(TAG, <span class="string">"transparentStatusBar: color = "</span> + color);</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> isLightTheme = <span class="keyword">false</span>;</span><br><span class="line">        Window window = activity.getWindow();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lightColors.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> selectColor = activity.getColor(lightColors[i]);</span><br><span class="line">            <span class="keyword">if</span> (selectColor == color) &#123;</span><br><span class="line">                isLightTheme = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是白色系列主题，则设置为黑字，默认是白字</span></span><br><span class="line">        <span class="keyword">if</span> (isLightTheme) &#123;</span><br><span class="line">            window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEMUI3_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"EmotionUI_3.1"</span>.equals(getEmuiVersion())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getEmuiVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; classType = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        classType = Class.forName(<span class="string">"android.os.SystemProperties"</span>);</span><br><span class="line">        Method getMethod = classType.getDeclaredMethod(<span class="string">"get"</span>, String.class);</span><br><span class="line">        <span class="keyword">return</span> (String) getMethod.invoke(classType, <span class="string">"ro.build.version.emui"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="对上述代码修改补充-2017-12-27-：华为EMUI3-1系统-statusBar-的特殊处理"><a href="#对上述代码修改补充-2017-12-27-：华为EMUI3-1系统-statusBar-的特殊处理" class="headerlink" title="对上述代码修改补充(2017/12/27)：华为EMUI3.1系统 statusBar 的特殊处理"></a>对上述代码修改补充(2017/12/27)：华为EMUI3.1系统 statusBar 的特殊处理</h5><ul>
<li><strong> 第四步：设置statusBar颜色 </strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置状态栏颜色</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(Activity activity, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">          <span class="comment">// 设置状态栏透明</span></span><br><span class="line">          <span class="comment">//  activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span></span><br><span class="line">          transparentStatusBar(activity);</span><br><span class="line">          <span class="comment">// 生成一个状态栏大小的矩形</span></span><br><span class="line">          View statusView = createStatusBarView(activity, color);</span><br><span class="line">          <span class="comment">// 添加 statusView 到布局中</span></span><br><span class="line">          ViewGroup decorView = (ViewGroup) activity.getWindow().getDecorView();</span><br><span class="line">          decorView.addView(statusView);</span><br><span class="line">          <span class="comment">//   设置根布局的参数</span></span><br><span class="line">          ViewGroup contentLayout = (ViewGroup) ((ViewGroup) 			activity.findViewById(android.R.id.content)).getChildAt(<span class="number">0</span>);</span><br><span class="line">          Log.w(TAG, <span class="string">"setColor: content paddingTop before set = "</span> + contentLayout.getPaddingTop());</span><br><span class="line">          contentLayout.setFitsSystemWindows(<span class="keyword">true</span>);</span><br><span class="line">          contentLayout.setClipToPadding(<span class="keyword">true</span>);</span><br><span class="line">          Log.w(TAG, <span class="string">"setColor: content paddingTop after set = "</span> + contentLayout.getPaddingTop());</span><br><span class="line">          <span class="comment">//为了适配不同手机的情况，可以在基类activity 中监听onWindowsFocusChange()看看根布局的padding是否等于</span></span><br><span class="line">          <span class="comment">//statusBar的高度，如果不等于（几乎大部分手机都是相等的，目前遇到的情况是努比亚的手机设置的padingTop特别小，</span></span><br><span class="line">          <span class="comment">// 导致内容布局与statusBar重叠） ，则手动设置paddingTop为statusBar的高度。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong> 第五步：在基类中设置statusBar (在setContentView(…)之后设置)</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterSetContentView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       StatusBarUtil.setColor(<span class="keyword">this</span>, getResources().getColor(R.color.app_white_bg));</span><br><span class="line">       initViews();</span><br><span class="line">       initData();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="填坑指南"><a href="#填坑指南" class="headerlink" title="填坑指南"></a>填坑指南</h4><p>  <code>关键的一步，主要是努比亚的手机的系统定制的比较特殊，在fitSystemWindow之后，对于根布局contentLayout设置的paddingTop并不等于 statusBar的高度，所以导致了内容布局会与statusBar重叠！！！网上的做法都是说重叠了就设置fitSystemWindow就可以，目前尚无对应的处理方法，所以接下来的解决方法就可能是你苦苦寻求的啦</code><br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听是否有设置正常的padding，有一些手机如努比亚手机就不会设置正常的statusBar的高度作为padding，</span></span><br><span class="line"><span class="comment"> * 导致内容布局与statusBar重叠的问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hasFocus</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onWindowFocusChanged(hasFocus);</span><br><span class="line">    Log.e(TAG, <span class="string">"onWindowFocusChanged: binding.getRoot().getPaddingTop() = "</span> + binding.getRoot().getPaddingTop());</span><br><span class="line">    <span class="keyword">if</span> (binding.getRoot().getPaddingTop() != StatusBarUtils.getStatusBarHeight(<span class="keyword">this</span>)) &#123;</span><br><span class="line">        binding.getRoot().setPadding(<span class="number">0</span>, StatusBarUtils.getStatusBarHeight(<span class="keyword">this</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="其实解决思路是很简单的，主要是找出问题的根源所在。还有一点就是在写界面布局时，-注意不要轻易在根布局里面设置paddingTop属性，经过测试发现，这个-paddingTop会被系统在fitSystemWindow之后帮你设置为-statusBar的高度（除了上面那个特殊情况，需要自己设置paddingTop）"><a href="#其实解决思路是很简单的，主要是找出问题的根源所在。还有一点就是在写界面布局时，-注意不要轻易在根布局里面设置paddingTop属性，经过测试发现，这个-paddingTop会被系统在fitSystemWindow之后帮你设置为-statusBar的高度（除了上面那个特殊情况，需要自己设置paddingTop）" class="headerlink" title="其实解决思路是很简单的，主要是找出问题的根源所在。还有一点就是在写界面布局时， 注意不要轻易在根布局里面设置paddingTop属性，经过测试发现，这个 paddingTop会被系统在fitSystemWindow之后帮你设置为 statusBar的高度（除了上面那个特殊情况，需要自己设置paddingTop）"></a>其实解决思路是很简单的，主要是找出问题的根源所在。还有一点就是在写界面布局时，<strong> 注意不要轻易在根布局里面设置paddingTop属性</strong>，经过测试发现，这个<strong> paddingTop</strong>会被系统在fitSystemWindow之后帮你设置为<strong> statusBar的高度</strong>（除了上面那个特殊情况，需要自己设置paddingTop）</h6><h4 id="附带：一个分析布局的工具Layout-Inspector"><a href="#附带：一个分析布局的工具Layout-Inspector" class="headerlink" title="附带：一个分析布局的工具Layout Inspector"></a>附带：一个分析布局的工具Layout Inspector</h4><p><img src="/img/AndroidstatusBar开发问题汇总/图片1.png" alt="图片1.png"></p>
<p><img src="/img/AndroidstatusBar开发问题汇总/图片2.png" alt="图片2.png"></p>
<p><strong> 附录·参考文献 </strong><br><a href="http://blog.chengyunfeng.com/?p=905#ixzz52GUtJQnQ" target="_blank" rel="noopener">该使用 fitsSystemWindows 了</a><br><a href="http://www.liuling123.com/2017/02/transparent-status-bar.html" target="_blank" rel="noopener">沉浸式状态栏实现及遇到的坑</a><strong> (重点推荐！) </strong></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> statusBar </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git常用命令简介]]></title>
      <url>/2017/12/18/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p><em>欢迎对文章内容进行补充和修正~</em></p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul>
<li>本文章转自网络<a href="https://www.cnblogs.com/TaylorApril/p/6815142.html" target="_blank" rel="noopener">github常用命令汇总</a></li>
<li>如有侵权，请作者及时联系删除。</li>
</ul>
<h3 id="创立版本库"><a href="#创立版本库" class="headerlink" title="创立版本库"></a>创立版本库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir Baidu</span><br><span class="line">cd Baidu</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>
<h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t -rsa -C &quot;TaylorApril947939@gmail&quot;</span><br><span class="line">（在github上new SSH，内容为id_rsa.pub）</span><br></pre></td></tr></table></figure>
<h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（github上新建git仓库,选择REAMDE.md）</span><br><span class="line">git remote add origin git@github.com:TaylorApril/Baidu.git</span><br><span class="line">git push -u origin master</span><br><span class="line">（报错）</span><br><span class="line">git pull --rebase origin master</span><br><span class="line">git push -u origin master</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<h3 id="提交-文件名字read-txt"><a href="#提交-文件名字read-txt" class="headerlink" title="提交(文件名字read.txt)"></a>提交(文件名字read.txt)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add read.txt</span><br><span class="line">（所有文件 git add .）</span><br><span class="line">git commit -m &quot;说明文字&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（查看最近到最远提交日志）</span><br><span class="line">git log --prtty=oneline</span><br><span class="line">（回退版本计数：HEAD^上一个版本、HEAD~100上与100个版本）</span><br><span class="line">git reset --hard HEAD^</span><br><span class="line">（回退版本号码：回退版本commit id为3628df）</span><br><span class="line">git reset --hard 3628df</span><br><span class="line">（想要恢复:使用命令记录来找回commit id回退）</span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">———&gt;              git add files              git commit </span><br><span class="line">working directory--------------stage-------------history</span><br><span class="line">&lt;———         git checkout --files         git reset --files</span><br></pre></td></tr></table></figure>
<h3 id="删除文件（read-txt）"><a href="#删除文件（read-txt）" class="headerlink" title="删除文件（read.txt）"></a>删除文件（read.txt）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rm read.txt</span><br><span class="line">（从版本库中删除）</span><br><span class="line">git rm read.txt</span><br><span class="line">git commit -m &quot;delete&quot;</span><br><span class="line">（删错了）</span><br><span class="line">git checkout -- read.txt</span><br></pre></td></tr></table></figure>
<h3 id="分支-分支名字dev"><a href="#分支-分支名字dev" class="headerlink" title="分支(分支名字dev)"></a>分支(分支名字dev)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">创建分支：git branch dev</span><br><span class="line">切换分支：git checkout dev</span><br><span class="line">创建+切换分支：git checkout -b dev</span><br><span class="line">查看当前分支：git branch</span><br><span class="line">切换回master分支：git checkout master</span><br><span class="line">合并指定分支到当前分支：git merge dev</span><br><span class="line">(fast-forward 快进模式)</span><br><span class="line">删除分支：git branch -d dev</span><br></pre></td></tr></table></figure>
<h3 id="解决冲突-分支名字fea"><a href="#解决冲突-分支名字fea" class="headerlink" title="解决冲突(分支名字fea)"></a>解决冲突(分支名字fea)</h3><ul>
<li>冲突原因：master和Dev同时增长。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b fea</span><br><span class="line">（修改Creating a new branch is quick AND simple.）</span><br><span class="line">git add read.txt</span><br><span class="line">git commit -m &quot;fea&quot;</span><br><span class="line">git checkout master</span><br><span class="line">（修改Creating a new branch is quick &amp; simple.）</span><br><span class="line">git addread.txt</span><br><span class="line">git commit -m &quot;master&quot;</span><br><span class="line">（此时形成了master和fea各自指着一个分支）</span><br><span class="line">git merge fea</span><br><span class="line">（合并错误，git status , cat read.txt可以查看）</span><br><span class="line">（修改read.txt的文本内容 Creating a new branch is quick and simple.）</span><br><span class="line">git add read.txt</span><br><span class="line">git commit -m “conf”</span><br><span class="line">（现在master和fea指向同一个人点了，git log可查看合并情况）</span><br><span class="line">git branch -d fea</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="分支管理策略（–no-ff）（分支名字dev-文件名字read-txt）"><a href="#分支管理策略（–no-ff）（分支名字dev-文件名字read-txt）" class="headerlink" title="分支管理策略（–no-ff）（分支名字dev 文件名字read.txt）"></a>分支管理策略（–no-ff）（分支名字dev 文件名字read.txt）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br><span class="line">git add read.txt</span><br><span class="line">git commit -m &quot;dev&quot;</span><br><span class="line">git checkout master</span><br><span class="line">（注意下个参数--no-ff,表示禁用fast forward）</span><br><span class="line">（fast forward合并看不出曾经做过合并，而--no-ff参数合并后的历史有分支，negative看出曾经做过合并）</span><br><span class="line">git merge --no-ff -m &quot;merge with --no-ff&quot; dev</span><br><span class="line">（查看分支历史 git log --graph --pretty=oneline --abbrev-commit）</span><br></pre></td></tr></table></figure>
<h3 id="bug分支-bugg分支为要解决bug的分支"><a href="#bug分支-bugg分支为要解决bug的分支" class="headerlink" title="bug分支(bugg分支为要解决bug的分支)"></a>bug分支(bugg分支为要解决bug的分支)</h3><ul>
<li>思想：当手头还有工作时，先将工作现场git stash(避免bug修复好后将为完成的工作一起提交),然后修复bug、提交之后，在用git stash pop将原来的工作显示在工作区 。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">（git status查看状态）</span><br><span class="line">git stash</span><br><span class="line">git checkout -b bugg</span><br><span class="line">（修改bug后）</span><br><span class="line">git add bugg.txt</span><br><span class="line">git commit -m &quot;fixed bug&quot;</span><br><span class="line">git checkout master</span><br><span class="line">git merge --no-ff -m &quot;merge bug&quot; bugg</span><br><span class="line">git branch -d bugg</span><br><span class="line">（接下来回到dev上继续工作）</span><br><span class="line">git checkout dev</span><br><span class="line">（查看工作区git status）</span><br><span class="line">（用git stash list查看）</span><br><span class="line">git stash list</span><br><span class="line">（恢复的第一种方法：恢复的同时把stash内容同时删除）</span><br><span class="line">git stash pop</span><br><span class="line">（恢复的第二种方法：恢复的同时不删除stash内容）</span><br><span class="line">git stash apply</span><br><span class="line">（若使用第二种方法想删除stash则用git stash drop）</span><br><span class="line">（若是多个文件stash 可用git stash apply stash@&#123;0&#125;恢复指定的stash）</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="feature分支-分支为dev"><a href="#feature分支-分支为dev" class="headerlink" title="feature分支(分支为dev)"></a>feature分支(分支为dev)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（在没完全完成合并时强行删除）</span><br><span class="line">git branch -D dev</span><br></pre></td></tr></table></figure>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（查看远程库信息）</span><br><span class="line">git remote</span><br><span class="line">（查看远程库更详细信息）</span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<h3 id="推送dev分支"><a href="#推送dev分支" class="headerlink" title="推送dev分支"></a>推送dev分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev</span><br></pre></td></tr></table></figure>
<h3 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">（克隆）</span><br><span class="line">git clone git@github.com:TaylorApril/test.git</span><br><span class="line">（查看能见分支 git branch）</span><br><span class="line">（在dev分支上开发，创建远程origin的dev分支到本地）</span><br><span class="line">git checkout -b dev origin/dev</span><br><span class="line">（修改后，进行提交）</span><br><span class="line">git commit -m &quot;add&quot;</span><br><span class="line">git push origin dev</span><br><span class="line">（在他提交之后你再push的情况时）</span><br><span class="line">（指定本地dev分支与远程origin分支链接）</span><br><span class="line">git branch</span><br><span class="line">git pull</span><br><span class="line">git commit -m &quot;fixed&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><h4 id="报错1"><a href="#报错1" class="headerlink" title="报错1"></a>报错1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">To git@github.com:TaylorApril/test.git</span><br><span class="line">! [rejected] master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to &apos;git@github.com:TaylorApril/test.git&apos;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &apos;git pull ...&apos;) before pushing again.</span><br><span class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</span><br></pre></td></tr></table></figure>
<ul>
<li>解决：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin master</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="报错2"><a href="#报错2" class="headerlink" title="报错2"></a>报错2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">Your branch is ahead of &apos;origin/master&apos; by 1 commit.</span><br><span class="line">(use &quot;git push&quot; to publish your local commits)</span><br></pre></td></tr></table></figure>
<ul>
<li>解决：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[视频码流格式解析]]></title>
      <url>/2017/12/15/%E8%A7%86%E9%A2%91%E7%A0%81%E6%B5%81%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="视频码流格式解析"><a href="#视频码流格式解析" class="headerlink" title="视频码流格式解析"></a>视频码流格式解析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在做视频直播功能的时候，接触到很多视频的相关概念，这些概念如果不了解，功能开发很难进行下去。本文仅用于记录在开发过程中接触到的关于H.264及H.265码流格式相关内容。</p>
<h2 id="视频封装格式"><a href="#视频封装格式" class="headerlink" title="视频封装格式"></a>视频封装格式</h2><p>在日常接触电脑视频文件的时候,可以发现视频文件通常会有不同的格式,用不同的后缀表示:avi,rmvb,mp4,flv等等。需要注意的是，这里的格式代表的是封装格式。封装格式是一种将音视频数据打包成一个文件的规范，其主要作用是把视频码流和音频码流按照一定的格式存储在一个文件中用以应对不同的播放需求。封装格式并不对视频图帧进行压缩，不同的封装格式对文件体积影响较小。<br><a id="more"></a><br>不同的视频封装格式里面存放的数据可能采用了多种不同的编码方式，现如今流行的封装格式如下表：</p>
<table>
<thead>
<tr>
<th>封装格式</th>
<th>推出机构</th>
<th>流媒体支持</th>
<th>视频编码支持</th>
<th>音频编码支持</th>
<th>使用领域</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVI</td>
<td>Microsoft Inc.</td>
<td>不支持</td>
<td>几乎所有格式</td>
<td>几乎所有格式</td>
<td>BT下载影视</td>
</tr>
<tr>
<td>MP4</td>
<td>MPEG</td>
<td>支持</td>
<td>MPEG-2,MPEG-4,H.264,H.263等</td>
<td>AAC,MPEG-1等</td>
<td>互联网视频网站</td>
</tr>
<tr>
<td>TS</td>
<td>MPEG</td>
<td>支持</td>
<td>MPEG-2,H.264,MPEG-4</td>
<td>AAC,MPEG-1等</td>
<td>数字电视</td>
</tr>
<tr>
<td>FLV</td>
<td>Adobe Inc.</td>
<td>支持</td>
<td>H.264,VP6</td>
<td>MP3,ACC,Linear PCM等</td>
<td>互联网视频网站</td>
</tr>
<tr>
<td>MKV</td>
<td>CoreCode Inc.</td>
<td>支持</td>
<td>几乎所有格式</td>
<td>几乎所有格式</td>
<td>互联网视频网站</td>
</tr>
</tbody>
</table>
<p>详细数据可<a href="http://en.wikipedia.org/wiki/Comparison_of_container_formats" target="_blank" rel="noopener">参考这里</a>。<br>从此表中可以发现，主流视频封装格式中，除了AVI之外，其他封装格式都支持流媒体。</p>
<h2 id="视频编码格式"><a href="#视频编码格式" class="headerlink" title="视频编码格式"></a>视频编码格式</h2><p>视频编码的主要作用是将视频像素数据（RGB，YUV等）压缩成为视频码流，从而降低视频数据量。当前主流的视频编码方案是H.264，H.265则将是未来编码趋势。</p>
<h3 id="H-264-AVC"><a href="#H-264-AVC" class="headerlink" title="H.264/AVC"></a>H.264/AVC</h3><p>H.264又称为<strong>MPEG-4第10部分，高级视频编码</strong>（MPEG-4 Part 10,Advanced Video Coding ,缩写为MPEG-4 AVC），是一种面向块，基于<a href="https://zh.wikipedia.org/wiki/运动补偿" target="_blank" rel="noopener">运动补偿</a>的<a href="https://en.wikipedia.org/wiki/Video_coding_format" target="_blank" rel="noopener">视频编码标准</a>。需要理解的是，H.264仅仅是一个编码标准，而不是一个具体的编码器，H.264只是给编码器的实现提供参照用的。<br>在H.264标准中，网络抽象层（NAL）和视频编码层（VCL）是两个主要概念：VCL即被压缩编码之后的视频数据序列，VCL数据与一些非VCL的视频描述数据封装成NAL数据，多个NAL单元（NALU）组成了H.264文件。</p>
<h4 id="NALU"><a href="#NALU" class="headerlink" title="NALU"></a>NALU</h4><p>NALU(Network Abstraction Layer Units，网络抽象层单元)是NAL的基本语法结构，每个NALU含一个字节的头信息以及封装了视频数据和配置数据的原始字节序列载荷（RBSP,Raw Byte Sequence Payload）字节流。</p>
<table><tr><td colspan="5" align="center">NAL结构</td></tr><tr><td>NALU header</td><td>RBSP</td><td>NALU header</td><td>RBSP</td><td>…</td></tr></table>

<p>每个NALU都可以被单独的解析和处理，但这并不代表一个单独的NALU数据就意味着是一个独立的帧，一个帧数据可以被分割成几个NALU，一个或多个NALU组成了一个Access Units（AU），AU包含了一个完整的帧。把帧分割成几个独立的NALU需要消耗许多CPU资源来进行计算，所以分割帧数据并不常用。<br>在一个NALU中，第一个字节（即NALU header）用以表示其包含数据的类型及其他信息。我们假定一个头信息字节为0x67作为例子：</p>
<table>
<thead>
<tr>
<th>十六进制</th>
<th>二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x67</td>
<td><font color="red">0</font>  <font color="green">11</font> <font color="orange">00111</font> </td>
</tr>
</tbody>
</table>
<p>如表所示，头字节可以被解析成3个部分，其中：</p>
<ul>
<li><strong><font color="red">forbidden_zero_bit</font> = 0</strong>：占1个bit，禁止位，用以检查传输过程中是否发生错误，0表示正常，1表示违反语法；</li>
<li><strong><font color="green">nal_ref_idc</font> = 3</strong>：占2个bit，用来表示当前NAL单元的优先级。非0值表示参考字段/帧/图片数据，其他不那么重要的数据则为0。对于非0值，值越大表示NALU重要性越高</li>
<li><strong><font color="orange">nal_unit_type</font> = 7</strong>：最后5位用以指定NALU类型，NALU类型定义如下</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">nal_unit_type</th>
<th style="text-align:center">NALU类型</th>
<th style="text-align:center">nal_ref_idc</th>
<th style="text-align:center">数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">未规定</td>
<td style="text-align:center"></td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">非IDR图片</td>
<td style="text-align:center">2，3，4</td>
<td style="text-align:center">VCL</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">编码片数据分区A</td>
<td style="text-align:center">2</td>
<td style="text-align:center">VCL</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">编码片数据分区B</td>
<td style="text-align:center">3</td>
<td style="text-align:center">VCL</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">编码片数据分区C</td>
<td style="text-align:center">4</td>
<td style="text-align:center">VCL</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">IDR图片</td>
<td style="text-align:center">2，3</td>
<td style="text-align:center">VCL</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">补充增强信息（SEI）</td>
<td style="text-align:center">5</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">序列参数集（SPS）</td>
<td style="text-align:center">0</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">图片参数集（PPS）</td>
<td style="text-align:center">1</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">访问单元分隔符</td>
<td style="text-align:center">6</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">序列结束</td>
<td style="text-align:center">7</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">码流结束</td>
<td style="text-align:center">8</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">填充数据</td>
<td style="text-align:center">9</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">序列参数集扩展</td>
<td style="text-align:center">10</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">NALU前缀</td>
<td style="text-align:center">2</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">序列参数集子集</td>
<td style="text-align:center">0</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">16-18</td>
<td style="text-align:center">保留</td>
<td style="text-align:center"></td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center">没有分区的辅助编码图片切片</td>
<td style="text-align:center">2，3，4</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">编码片扩展</td>
<td style="text-align:center">2，3，4</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td style="text-align:center">深度试图组建编码片扩展</td>
<td style="text-align:center">2，3，4</td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">22-23</td>
<td style="text-align:center">保留</td>
<td style="text-align:center"></td>
<td style="text-align:center">非VCL</td>
</tr>
<tr>
<td style="text-align:center">24-31</td>
<td style="text-align:center">不明</td>
<td style="text-align:center"></td>
<td style="text-align:center">非VCL</td>
</tr>
</tbody>
</table>
<p>从表中我们可以获知,NALU类型1-5为视频帧，其余则为非视频帧。在解码过程中，我们只需要取出NALU头字节的后5位，即将NALU头字节和<code>0x1F</code>进行与计算即可得知NALU类型，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NALU类型 = NALU头字节 &amp; 0x1F</span><br></pre></td></tr></table></figure>
<p>在NALU类型数据中，我们除了需要关注VCL数据之外，还需要关注另外两个数据类型：SPS和PPS。</p>
<h5 id="SPS"><a href="#SPS" class="headerlink" title="SPS"></a>SPS</h5><p>SPS(Sequence Parameter Set,序列参数集)，NALU数据类型为7。SPS中保存了一组编码视频序列的全局参数，包括计算图像宽度及高度的参数、参考帧数等。在H.264中SPS的信息至关重要，如果其中的数据丢失或出错，那么解码过程很可能会失败。</p>
<h5 id="PPS"><a href="#PPS" class="headerlink" title="PPS"></a>PPS</h5><p>PPS(Picture Parameter Set,图像参数集),NALU数据类型为8，其中包含视频熵编码标识（用以表示码流中熵编码/解码选择的算法）、视频宏块进行帧内预测使用的宏块信息等。</p>
<p>在视频解码过程中，SPS和PPS包含了初始化H.264解码器所需要的信息参数。</p>
<h4 id="码流格式"><a href="#码流格式" class="headerlink" title="码流格式"></a>码流格式</h4><p>H.264标准中指定了视频如何编码成独立的包，但如何存储和传输这些包却未作规范，虽然标准中包含了一个Annex附件，里面描述了一种可能的格式Annex B，但这并不是一个必须要求的格式。<br>为了针对不同的存储传输需求，出现了两种打包方法。一种即Annex B格式，另一种称为AVCC格式。</p>
<h5 id="Annex-B"><a href="#Annex-B" class="headerlink" title="Annex B"></a>Annex B</h5><p>从上文可知，一个NALU中的数据并未包含他的大小（长度）信息，因此我们并不能简单的将一个个NALU连接起来生成一个流，因为数据流的接收端并不知道一个NALU从哪里结束，另一个NALU从哪里开始。<br>Annex B格式用起始码（Start Code）来解决这个问题，它在每个NALU的开始处添加三字节或四字节的起始码<code>0x000001</code>或<code>0x00000001</code>。通过定位起始码，解码器就可以很容易的识别NALU的边界。<br>当然，用起始码定位NALU边界存在一个问题，即NALU中可能存在与起始码相同的数据。为了防止这个问题，在构建NALU时，需要将数据中的<code>0x000000</code>,<code>0x000001</code>,<code>0x000002</code>,<code>0x000003</code>中插入防竞争字节（Emulation Prevention Bytes)<code>0x03</code>，使其变为：</p>
<ul>
<li>0x000000 = 0x0000 <font color="red">03</font> 00</li>
<li>0x000001 = 0x0000 <font color="red">03</font> 01</li>
<li>0x000002 = 0x0000 <font color="red">03</font> 02</li>
<li>0x000003 = 0x0000 <font color="red">03</font> 03</li>
</ul>
<p>解码器在检测到0x000003时，将0x03抛弃，恢复原始数据。</p>
<p>由于Annex B格式每个NALU都包含起始码，所以解码器可以从视频流随机点开始进行解码，常用于实时的流格式。在这种格式中通常会周期性的重复SPS和PPS，并且经常时在每一个关键帧之前。</p>
<h5 id="AVCC"><a href="#AVCC" class="headerlink" title="AVCC"></a>AVCC</h5><p>AVCC格式不使用起始码作为NALU的分界，这种格式再每个NALU前都加上一个指定NALU长度的大端格式表示的前缀。这个前缀可以是1、2或4个字节，所以在解析AVCC格式的时候需要将指定的前缀字节数的值保存在一个头部对象中，这个都通常称为<code>extradata</code>或者<code>sequence header</code>。同时，SPS和PPS数据也需要保存在<code>extradata</code>中。<br>H.264 extradata语法如下：</p>
<table>
<thead>
<tr>
<th>bits</th>
<th>line by byte</th>
<th>remark</th>
</tr>
</thead>
<tbody>
<tr>
<td>8</td>
<td>version</td>
<td>always 0x01</td>
</tr>
<tr>
<td>8</td>
<td>avc profile</td>
<td>sps[0][1]</td>
</tr>
<tr>
<td>8</td>
<td>avc compatibility</td>
<td>sps[0][2]</td>
</tr>
<tr>
<td>8</td>
<td>avc level</td>
<td>sps[0][3]</td>
</tr>
<tr>
<td>6</td>
<td>reserved</td>
<td>all bits on</td>
</tr>
<tr>
<td>2</td>
<td>NALULengthSizeMinusOne</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>reserved</td>
<td>all bits on</td>
</tr>
<tr>
<td>5</td>
<td>number of SPS NALUs</td>
<td>usually 1</td>
</tr>
<tr>
<td>16</td>
<td>SPS size</td>
<td></td>
</tr>
<tr>
<td>N</td>
<td>variable SPS NALU data</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>number of PPS NALUs</td>
<td>usually 1</td>
</tr>
<tr>
<td>16</td>
<td>PPS size</td>
<td></td>
</tr>
<tr>
<td>N</td>
<td>variable PPS NALU data</td>
</tr>
</tbody>
</table>
<p>其中第5字节的后2位表示的就是NAL size的字节数。需要注意的是，这个NALULengthSizeMinusOne是NALU前缀长度减一，即，假设前缀长度为4，那么这个值应该为3。<br>这里还需要注意的一点是，虽然AVCC格式不使用起始码，但防竞争字节还是有的。</p>
<p>AVCC格式的一个优点在于解码器配置参数在一开始就配置好了，系统可以很容易的识别NALU的边界，不需要额外的起始码，减少了资源的浪费，同时可以在播放时调到视频的中间位置。这种格式通常被用于可以被随机访问的多媒体数据，如存储在硬盘的文件。</p>
<h3 id="H-265-HEVC"><a href="#H-265-HEVC" class="headerlink" title="H.265/HEVC"></a>H.265/HEVC</h3><p>HEVC全称High Efficiency Video Coding(高效率视频编码，又称H.265)，是比H.264更家优秀的一种视频压缩标准。HEVC在低码率视频压缩上，提升视频质量、减少容量即节省带宽方面都有突出表现。<br>H.265标准围绕H.264编码标准,保留原有的某些技术，同时对一些技术进行改进，编码结构大致上和H.264的架构类似。这里着重讲一下两者编码格式的区别。<br>同H.264一样，H.265也是以NALU的形式组织起来。而在NALU header上，H.264的HALU header是一个字节，而H.265则是两个字节。我们同样假定一个头信息为0x4001作为例子：</p>
<table>
<thead>
<tr>
<th>十六进制</th>
<th>二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x4001</td>
<td><font color="red">0</font>  <font color="green">100000</font> <font color="orange">000000</font> <font color="blue">001</font></td>
</tr>
</tbody>
</table>
<p>如表所示，头信息可以被解析成4个部分，其中：</p>
<ul>
<li><strong><font color="red">forbidden_zero_bit</font> = 0</strong>：占1个bit，与H.264相同，禁止位，用以检查传输过程中是否发生错误，0表示正常，1表示违反语法；</li>
<li><strong><font color="green">nal_unit_type</font> = 32</strong>：占6个bit，用来用以指定NALU类型</li>
<li><strong><font color="orange">nuh_reserved_zero_6bits</font> = 0</strong>：占6位，预留位，要求为0，用于未来扩展或3D视频编码</li>
<li><strong><font color="blue">nuh_temporal_id_plus1</font> = 1</strong>：占3个bit，表示NAL所在的时间层ID</li>
</ul>
<p>对比H.264的头信息，H.265移除了nal_ref_idc，此信息被合并到了nal_unit_type中，H.265NALU类型规定如下:</p>
<table><tr><td>nal_unit_type</td><td>NALU类型</td><td>备注</td></tr><tr><td>0</td><td>NAL_UNIT_CODE_SLICE_TRAIL_N</td><td rowspan="10">非关键帧</td></tr><tr><td>1</td><td>NAL_UNIT_CODED_SLICE_TRAIL_R</td></tr><tr><td>2</td><td>NAL_UNIT_CODED_SLICE_TSA_N</td></tr><tr><td>3</td><td>NAL_UINT_CODED_SLICE_TSA_R</td></tr><tr><td>4</td><td>NAL_UINT_CODED_SLICE_STSA_N</td></tr><tr><td>5</td><td>NAL_UINT_CODED_SLICE_STSA_R</td></tr><tr><td>6</td><td>NAL_UNIT_CODED_SLICE_RADL_N</td></tr><tr><td>7</td><td>NAL_UNIT_CODED_SLICE_RADL_R</td></tr><tr><td>8</td><td>NAL_UNIT_CODED_SLICE_RASL_N</td>   </tr><tr><td>9</td><td>NAL_UNIT_CODE_SLICE_RASL_R</td></tr><tr><td>10 ~ 15</td><td>NAL_UNIT_RESERVED_X</td><td>保留</td></tr><tr><td>16</td><td>NAL_UNIT_CODED_SLICE_BLA_W_LP</td><td rowspan="6">关键帧</td></tr><tr><td>17</td><td>NAL_UNIT_CODE_SLICE_BLA_W_RADL</td></tr><tr><td>18</td><td>NAL_UNIT_CODE_SLICE_BLA_N_LP</td></tr><tr><td>19</td><td>NAL_UNIT_CODE_SLICE_IDR_W_RADL</td>  </tr><tr><td>20</td><td>NAL_UNIT_CODE_SLICE_IDR_N_LP</td></tr><tr><td>21</td><td>NAL_UNIT_CODE_SLICE_CRA</td></tr><tr><td>22 ~ 31</td><td>NAL_UNIT_RESERVED_X</td><td>保留</td></tr>   <tr>      <td>32</td>      <td>NAL_UNIT_VPS</td>      <td>VPS(Video Paramater Set)</td>   </tr>   <tr>      <td>33</td>     <td>NAL_UNIT_SPS</td>     <td>SPS</td>   </tr>   <tr>      <td>34</td>    <td>NAL_UNIT_PPS</td>      <td>PPS</td>   </tr>   <tr>      <td>35</td>     <td>NAL_UNIT_ACCESS_UNIT_DELIMITER</td>     <td></td>  </tr>  <tr>     <td>36</td>     <td>NAL_UNIT_EOS</td>     <td></td>  </tr>  <tr>     <td>37</td>      <td>NAL_UNIT_EOB</td>      <td></td>   </tr>   <tr>      <td>38</td>      <td>NAL_UNIT_FILLER_DATA</td>      <td></td>   </tr>   <tr>      <td>39</td>      <td>NAL_UNIT_SEI</td>      <td>Prefix SEI</td>   </tr>  <tr>      <td>40</td>      <td>NAL_UNIT_SEI_SUFFIX</td>      <td>Suffix SEI</td>   </tr>   <tr>     <td>41 ~ 47</td>      <td>NAL_UNIT_RESERVED_X</td>      <td>保留</td>   </tr>   <tr>      <td>48 ~ 63</td>      <td>NAL_UNIT_UNSPECIFIED_X</td>      <td>未规定</td>   </tr>   <tr>      <td>64</td>      <td>NAL_UNIT_INVALID</td>      <td></td>   </tr></table>

<p>具体type含义可以<a href="https://tools.ietf.org/html/draft-ietf-payload-rtp-h265-15" target="_blank" rel="noopener">参考这篇文档</a>第3.2节。<br>H.265的NALU类型是在信息头的第一个字节的第2到7位，所以判断H.265NALU类型的方法是将NALU第一个字节与<code>0x7E</code>进行与操作并右移一位，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NALU类型 = (NALU头第一字节 &amp; 0x7E) &gt;&gt; 1</span><br></pre></td></tr></table></figure>
<p>与H.264类似，H.265码流也有两种封装格式，一种是用起始码作为分界的Annex B格式，另一种则是在NALU头添加NALU长度前缀的格式，称为HVCC。在HVCC中，同样需要一个extradata来保存视频流的编解码参数，其格式定义如下：</p>
<table>   <tr>      <td>bits</td>      <td>line by byte</td>      <td>remark</td>   </tr>   <tr>      <td>8</td> <td>configurationVersion</td>      <td>always 0x01</td>   </tr>   <tr>      <td>2</td>      <td>general_profile_space</td>      <td></td>   </tr>   <tr>      <td>1</td>      <td>general_tier_flag</td>    <td></td>   </tr>  <tr>      <td>5</td>      <td>general_profile_idc</td>      <td></td>  </tr>   <tr>      <td>32</td>      <td>general_profile_compatibility_flags</td>     <td></td>   </tr>   <tr>      <td>48</td>      <td>general_constraint_indicator_flags</td>      <td></td>   </tr>   <tr>     <td>8</td>      <td>general_level_idc</td>      <td></td>   </tr>   <tr>      <td>4</td>     <td>reserved</td>      <td>‘1111’b</td>   </tr>   <tr>      <td>12</td>      <td>min_spatial_segmentation_idc</td>      <td></td>   </tr>  <tr>      <td>6</td>      <td>reserved</td>      <td>‘111111’b</td>   </tr>   <tr>      <td>2</td>    <td>parallelismType</td>      <td></td>   </tr>   <tr>      <td>6</td>      <td>reserved</td>      <td>‘111111’b</td>   </tr>   <tr>      <td>2</td>      <td>chromaFormat</td>      <td></td>   </tr>   <tr>      <td>5</td>      <td>reserved</td>     <td>‘11111’b</td>   </tr>   <tr>      <td>3</td>      <td>bitDepthLumaMinus8</td>     <td></td>   </tr>   <tr>      <td>5</td>      <td>reserved</td>      <td>‘11111’b</td>   </tr>   <tr>      <td>3</td>      <td>bitDepthChromaMinus8</td>      <td></td>   </tr>   <tr>      <td>16</td>     <td>avgFrameRate</td>     <td></td>   </tr>   <tr>      <td>2</td>      <td>constantFrameRate</td>      <td></td>   </tr>   <tr>      <td>3</td>      <td>numTemporalLayers</td>     <td></td>   </tr>   <tr>      <td>1</td>      <td>tmporalIdNested</td>      <td></td>   </tr>   <tr>      <td>2</td>      <td>lengthSizeMinusOne</td>      <td></td>   </tr>   <tr>      <td>8</td>      <td>numOfArrays</td>      <td></td>  </tr>   <tr>      <td colspan="3"> Repeated of Array(VPS/SPS/PPS)</td>   </tr>   <tr>      <td>1</td>      <td>array_completeness</td>      <td></td>   </tr>   <tr>      <td>1</td>      <td>reserved</td>      <td>‘0’b</td>   </tr>   <tr>      <td>6</td>      <td>NAL_unit_type</td>      <td></td>   </tr>   <tr>     <td>16</td>      <td>numNalus</td>      <td></td>   </tr>   <tr>      <td>16</td>      <td>nalUnitLength</td>      <td></td>   </tr>   <tr>      <td>N</td>      <td>NALU data</td>     <td></td>   </tr></table>

<p>从上表可以看到，在H.265的extradata后半段是一段格式重复的数组数据，里面需要包含的除了与H.264相同的SPS、PPS外，还需多添加一个VPS。</p>
<p>VPS（Video Parament Set,视频参数集),在H.265中类型为32。VPS用于解释编码过的视频的整体结构，包括时域子层依赖关系等，主要目的在于兼容H.265标准在系统的多子层方面的扩展。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="http://yumichan.net/video-processing/video-compression/introduction-to-h264-nal-unit" target="_blank" rel="noopener">Introduction to H.164</a><br>2.<a href="https://zh.wikipedia.org/wiki/H.264" target="_blank" rel="noopener">H.264 wiki</a><br>3.<a href="http://blog.csdn.net/leixiaohua1020/article/details/18893769" target="_blank" rel="noopener">音视频编解码技术零基础学习方法</a><br>4.<a href="https://stackoverflow.com/questions/24884827/possible-llocations-for-sequence-picture-parameter-sets-for-h-264-stream/24890903#24890903" target="_blank" rel="noopener">Possible Locations for Sequence/Picture Parameter Set(s) for H.264 Stream  answer by szatmary</a><br>5.<a href="https://www.cnblogs.com/TaigaCon/p/5215448" target="_blank" rel="noopener">h.264语法结构分析</a></p>
]]></content>
      
        <categories>
            
            <category> 视频编解码 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 视频码流 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[破解摩拜成为私家车的有效方法]]></title>
      <url>/2017/12/07/%E7%A0%B4%E8%A7%A3%E6%91%A9%E6%8B%9C%E6%88%90%E4%B8%BA%E7%A7%81%E5%AE%B6%E8%BD%A6%E7%9A%84%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step.1"></a>Step.1</h3><ul>
<li>找到想要预约的摩拜单车，预约即可看到单车编码</li>
</ul>
<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step.2"></a>Step.2</h3><ul>
<li>将上网开关关闭再打开，即可看到寻车铃按钮可以点击了</li>
<li>听到声音确认车辆</li>
</ul>
<h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step.3"></a>Step.3</h3><ul>
<li>手动输入编号即可</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>预约功能每天只有三次，可尝试机会不多哦</li>
<li>输错你暂时就别想再骑了</li>
</ul>
<p>毕生功力都传给你们了，不用客气。。。。。</p>
]]></content>
      
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[内存泄漏总结]]></title>
      <url>/2017/12/06/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="转-Android-内存泄漏总结"><a href="#转-Android-内存泄漏总结" class="headerlink" title="(转)Android 内存泄漏总结"></a>(转)Android 内存泄漏总结</h1><h4 id="资料总结来源于网络，如有侵权，请第一时间告知。"><a href="#资料总结来源于网络，如有侵权，请第一时间告知。" class="headerlink" title=" 资料总结来源于网络，如有侵权，请第一时间告知。 "></a><em> 资料总结来源于网络，如有侵权，请第一时间告知。 </em></h4><p>内存管理的目的就是让我们在开发中怎么有效的避免我们的应用出现内存泄漏的问题。内存泄漏大家都不陌生了，简单粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收。最近自己阅读了大量相关的文档资料，打算做个 总结 沉淀下来跟大家一起分享和学习，也给自己一个警示，以后 coding 时怎么避免这些情况，提高应用的体验和质量。</p>
<p>我会从 java 内存泄漏的基础知识开始，并通过具体例子来说明 Android 引起内存泄漏的各种原因，以及如何利用工具来分析应用内存泄漏，最后再做总结。<br><a id="more"></a></p>
<h2 id="Java-内存分配策略"><a href="#Java-内存分配策略" class="headerlink" title="Java 内存分配策略"></a>Java 内存分配策略</h2><p>Java 程序运行时的内存分配策略有三种,分别是静态分配,栈式分配,和堆式分配，对应的，三种存储策略使用的内存空间主要分别是静态存储区（也称方法区）、栈区和堆区。</p>
<ul>
<li><p>静态存储区（方法区）：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。</p>
</li>
<li><p>栈区 ：当方法被执行时，方法体内的局部变量（其中包括基础数据类型、对象的引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
</li>
<li><p>堆区 ： 又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存，也就是对象的实例。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。</p>
</li>
</ul>
<p>##栈与堆的区别：</p>
<p>在方法体内定义的（局部变量）一些基本类型的变量和对象的引用变量都是在方法的栈内存中分配的。当在一段方法块中定义一个变量时，Java 就会在栈中为该变量分配内存空间，当超过该变量的作用域后，该变量也就无效了，分配给它的内存空间也将被释放掉，该内存空间可以被重新使用。</p>
<p>堆内存用来存放所有由 new 创建的对象（包括该对象其中的所有成员变量）和数组。在堆中分配的内存，将由 Java 垃圾回收器来自动管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，这个特殊的变量就是我们上面说的引用变量。我们可以通过这个引用变量来访问堆中的对象或者数组。</p>
<p>举个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Sample &#123;</span><br><span class="line">    int s1 = 0;</span><br><span class="line">    Sample mSample1 = new Sample();</span><br><span class="line"></span><br><span class="line">    public void method() &#123;</span><br><span class="line">        int s2 = 1;</span><br><span class="line">        Sample mSample2 = new Sample();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sample mSample3 = new Sample();</span><br></pre></td></tr></table></figure>
<p>Sample 类的局部变量 s2 和引用变量 mSample2 都是存在于栈中，但 mSample2 指向的对象是存在于堆上的。<br>mSample3 指向的对象实体存放在堆上，包括这个对象的所有成员变量 s1 和 mSample1，而它自己存在于栈中。</p>
<p>结论：</p>
<p>局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储于堆中。—— 因为它们属于方法中的变量，生命周期随方法而结束。</p>
<p>成员变量全部存储与堆中（包括基本数据类型，引用和引用的对象实体）—— 因为它们属于类，类对象终究是要被new出来使用的。</p>
<p>了解了 Java 的内存分配之后，我们再来看看 Java 是怎么管理内存的。</p>
<p>##Java是如何管理内存</p>
<p>Java的内存管理就是对象的分配和释放问题。在 Java 中，程序员需要通过关键字 new 为每个对象申请内存空间 (基本类型除外)，所有的对象都在堆 (Heap)中分配空间。另外，对象的释放是由 GC 决定和执行的。在 Java 中，内存的分配是由程序完成的，而内存的释放是由 GC 完成的，这种收支两条线的方法确实简化了程序员的工作。但同时，它也加重了JVM的工作。这也是 Java 程序运行速度较慢的原因之一。因为，GC 为了能够正确释放对象，GC 必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC 都需要进行监控。</p>
<p>监视对象状态是为了更加准确地、及时地释放对象，而释放对象的根本原则就是该对象不再被引用。</p>
<p>为了更好理解 GC 的工作原理，我们可以将对象考虑为有向图的顶点，将引用关系考虑为图的有向边，有向边从引用者指向被引对象。另外，每个线程对象可以作为一个图的起始顶点，例如大多程序从 main 进程开始执行，那么该图就是以 main 进程顶点开始的一棵根树。在这个有向图中，根顶点可达的对象都是有效对象，GC将不回收这些对象。如果某个对象 (连通子图)与这个根顶点不可达(注意，该图为有向图)，那么我们认为这个(这些)对象不再被引用，可以被 GC 回收。<br>以下，我们举一个例子说明如何用有向图表示内存管理。对于程序的每一个时刻，我们都有一个有向图表示JVM的内存分配情况。以下右图，就是左边程序运行到第6行的示意图。</p>
<p><img src="http://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/1.gif" alt=""></p>
<p>Java使用有向图的方式进行内存管理，可以消除引用循环的问题，例如有三个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的。这种方式的优点是管理内存的精度很高，但是效率较低。另外一种常用的内存管理技术是使用计数器，例如COM模型采用计数器方式管理构件，它与有向图相比，精度行低(很难处理循环引用的问题)，但执行效率很高。</p>
<p>##什么是Java中的内存泄露</p>
<p>在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</p>
<p>在C++中，内存泄漏的范围更大一些。有些对象被分配了内存空间，然后却不可达，由于C++中没有GC，这些内存将永远收不回来。在Java中，这些不可达的对象都由GC负责回收，因此程序员不需要考虑这部分的内存泄露。</p>
<p>通过分析，我们得知，对于C++，程序员需要自己管理边和顶点，而对于Java程序员只需要管理边就可以了(不需要管理顶点的释放)。通过这种方式，Java提高了编程的效率。</p>
<p><img src="http://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/2.gif" alt=""></p>
<p>因此，通过以上分析，我们知道在Java中也有内存泄漏，但范围比C++要小一些。因为Java从语言上保证，任何对象都是可达的，所有的不可达对象都由GC管理。</p>
<p>对于程序员来说，GC基本是透明的，不可见的。虽然，我们只有几个函数可以访问GC，例如运行GC的函数System.gc()，但是根据Java语言规范定义， 该函数不保证JVM的垃圾收集器一定会执行。因为，不同的JVM实现者可能使用不同的算法管理GC。通常，GC的线程的优先级别较低。JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。但通常来说，我们不需要关心这些。除非在一些特定的场合，GC的执行影响应用程序的性能，例如对于基于Web的实时系统，如网络游戏等，用户不希望GC突然中断应用程序执行而进行垃圾回收，那么我们需要调整GC的参数，让GC能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行，Sun提供的HotSpot JVM就支持这一特性。</p>
<p>同样给出一个 Java 内存泄漏的典型例子，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vector v = new Vector(10);</span><br><span class="line">for (int i = 1; i &lt; 100; i++) &#123;</span><br><span class="line">    Object o = new Object();</span><br><span class="line">    v.add(o);</span><br><span class="line">    o = null;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们循环申请Object对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。</p>
<p><strong>详细Java中的内存泄漏</strong></p>
<p>1.Java内存回收机制</p>
<p>不论哪种语言的内存分配方式，都需要返回所分配内存的真实地址，也就是返回一个指针到内存块的首地址。Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控，Java会使用有向图的方法进行管理内存，实时监控对象是否可以达到，如果不可到达，则就将其回收，这样也可以消除引用循环的问题。在Java语言中，判断一个内存空间是否符合垃圾收集标准有两个：一个是给对象赋予了空值null，以下再没有调用过，另一个是给对象赋予了新值，这样重新分配了内存空间。 </p>
<p>2.Java内存泄漏引起的原因</p>
<p>内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。j</p>
<p>Java内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。具体主要有如下几大类：</p>
<p>1、静态集合类引起内存泄漏：</p>
<p>像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。 </p>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Static Vector v = new Vector(10);</span><br><span class="line">for (int i = 1; i&lt;100; i++)</span><br><span class="line">&#123;</span><br><span class="line">Object o = new Object();</span><br><span class="line">v.add(o);</span><br><span class="line">o = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。</p>
<p>2、当集合里面的对象属性被修改后，再调用remove()方法时不起作用。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Set&lt;Person&gt; set = new HashSet&lt;Person&gt;();</span><br><span class="line">Person p1 = new Person(&quot;唐僧&quot;,&quot;pwd1&quot;,25);</span><br><span class="line">Person p2 = new Person(&quot;孙悟空&quot;,&quot;pwd2&quot;,26);</span><br><span class="line">Person p3 = new Person(&quot;猪八戒&quot;,&quot;pwd3&quot;,27);</span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line">set.add(p3);</span><br><span class="line">System.out.println(&quot;总共有:&quot;+set.size()+&quot; 个元素!&quot;); //结果：总共有:3 个元素!</span><br><span class="line">p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变</span><br><span class="line"></span><br><span class="line">set.remove(p3); //此时remove不掉，造成内存泄漏</span><br><span class="line"></span><br><span class="line">set.add(p3); //重新添加，居然添加成功</span><br><span class="line">System.out.println(&quot;总共有:&quot;+set.size()+&quot; 个元素!&quot;); //结果：总共有:4 个元素!</span><br><span class="line">for (Person person : set)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(person);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、监听器</p>
<p>在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。</p>
<p>4、各种连接 </p>
<p>比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。</p>
<p>5、内部类和外部模块的引用</p>
<p>内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：<br>public void registerMsg(Object b);<br>这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。</p>
<p>6、单例模式 </p>
<p>不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏，考虑下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public A()&#123;</span><br><span class="line">B.getInstance().setA(this);</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">//B类采用单例模式</span><br><span class="line">class B&#123;</span><br><span class="line">private A a;</span><br><span class="line">private static B instance=new B();</span><br><span class="line">public B()&#123;&#125;</span><br><span class="line">public static B getInstance()&#123;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">public void setA(A a)&#123;</span><br><span class="line">this.a=a;</span><br><span class="line">&#125;</span><br><span class="line">//getter...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收。想象下如果A是个比较复杂的对象或者集合类型会发生什么情况</p>
<h2 id="Android中常见的内存泄漏汇总"><a href="#Android中常见的内存泄漏汇总" class="headerlink" title="##Android中常见的内存泄漏汇总"></a>##Android中常见的内存泄漏汇总</h2><p>###集合类泄漏</p>
<p>集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量 (比如类中的静态属性，全局性的 map 等即有静态引用或 final 一直指向它)，那么没有相应的删除机制，很可能导致集合所占用的内存只增不减。比如上面的典型例子就是其中一种情况，当然实际上我们在项目中肯定不会写这么 2B 的代码，但稍不注意还是很容易出现这种情况，比如我们都喜欢通过 HashMap 做一些缓存之类的事，这种情况就要多留一些心眼。</p>
<p>###单例造成的内存泄漏</p>
<p>由于单例的静态特性使得其生命周期跟应用的生命周期一样长，所以如果使用不恰当的话，很容易造成内存泄漏。比如下面一个典型的例子，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class AppManager &#123;</span><br><span class="line">private static AppManager instance;</span><br><span class="line">private Context context;</span><br><span class="line">private AppManager(Context context) &#123;</span><br><span class="line">this.context = context;</span><br><span class="line">&#125;</span><br><span class="line">public static AppManager getInstance(Context context) &#123;</span><br><span class="line">if (instance == null) &#123;</span><br><span class="line">instance = new AppManager(context);</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个Context，所以这个Context的生命周期的长短至关重要：</p>
<p>1、如果此时传入的是 Application 的 Context，因为 Application 的生命周期就是整个应用的生命周期，所以这将没有任何问题。</p>
<p>2、如果此时传入的是 Activity 的 Context，当这个 Context 所对应的 Activity 退出时，由于该 Context 的引用被单例对象所持有，其生命周期等于整个应用程序的生命周期，所以当前 Activity 退出时它的内存并不会被回收，这就造成泄漏了。</p>
<p>正确的方式应该改为下面这种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class AppManager &#123;</span><br><span class="line">private static AppManager instance;</span><br><span class="line">private Context context;</span><br><span class="line">private AppManager(Context context) &#123;</span><br><span class="line">this.context = context.getApplicationContext();// 使用Application 的context</span><br><span class="line">&#125;</span><br><span class="line">public static AppManager getInstance(Context context) &#123;</span><br><span class="line">if (instance == null) &#123;</span><br><span class="line">instance = new AppManager(context);</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者这样写，连 Context 都不用传进来了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">在你的 Application 中添加一个静态方法，getContext() 返回 Application 的 context，</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">context = getApplicationContext();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">   /**</span><br><span class="line">     * 获取全局的context</span><br><span class="line">     * @return 返回全局context对象</span><br><span class="line">     */</span><br><span class="line">    public static Context getContext()&#123;</span><br><span class="line">        return context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public class AppManager &#123;</span><br><span class="line">private static AppManager instance;</span><br><span class="line">private Context context;</span><br><span class="line">private AppManager() &#123;</span><br><span class="line">this.context = MyApplication.getContext();// 使用Application 的context</span><br><span class="line">&#125;</span><br><span class="line">public static AppManager getInstance() &#123;</span><br><span class="line">if (instance == null) &#123;</span><br><span class="line">instance = new AppManager();</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###匿名内部类/非静态内部类和异步线程</p>
<p>非静态内部类创建静态实例造成的内存泄漏</p>
<p>有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现这种写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">private static TestResource mResource = null;</span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line">if(mManager == null)&#123;</span><br><span class="line">mManager = new TestResource();</span><br><span class="line">&#125;</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br><span class="line">class TestResource &#123;</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。正确的做法为：</p>
<p>将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，请按照上面推荐的使用Application 的 Context。当然，Application 的 context 不是万能的，所以也不能随便乱用，对于有些地方则必须使用 Activity 的 Context，对于Application，Service，Activity三者的Context的应用场景如下：</p>
<p><img src="http://img.blog.csdn.net/20151123144226349?spm=5176.100239.blogcont.9.CtU1c4" alt=""></p>
<p>其中： NO1表示 Application 和 Service 可以启动一个 Activity，不过需要创建一个新的 task 任务队列。而对于 Dialog 而言，只有在 Activity 中才能创建</p>
<p>###匿名内部类</p>
<p>android开发经常会继承实现Activity/Fragment/View，此时如果你使用了匿名类，并被异步线程持有了，那要小心了，如果没有任何措施这样一定会导致泄露</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">...</span><br><span class="line">Runnable ref1 = new MyRunable();</span><br><span class="line">Runnable ref2 = new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ref1和ref2的区别是，ref2使用了匿名内部类。我们来看看运行时这两个引用的内存：</p>
<p><img src="http://img2.tbcdn.cn/L1/461/1/fb05ff6d2e68f309b94dd84352c81acfe0ae839e?spm=5176.100239.blogcont.10.CtU1c4" alt=""></p>
<p>可以看到，ref1没什么特别的。</p>
<p>但ref2这个匿名类的实现对象里面多了一个引用：</p>
<p>this$0这个引用指向MainActivity.this，也就是说当前的MainActivity实例会被ref2持有，如果将这个引用再传入一个异步线程，此线程和此Acitivity生命周期不一致的时候，就造成了Activity的泄露。</p>
<p>###Handler 造成的内存泄漏</p>
<p>Handler 的使用造成的内存泄漏问题应该说是最为常见了，很多时候我们为了避免 ANR 而不在主线程进行耗时操作，在处理网络任务或者封装一些请求回调等api都借助Handler来处理，但 Handler 不是万能的，对于 Handler 的使用代码编写一不规范即有可能造成内存泄漏。另外，我们知道 Handler、Message 和 MessageQueue 都是相互关联在一起的，万一 Handler 发送的 Message 尚未被处理，则该 Message 及发送它的 Handler 对象将被线程 MessageQueue 一直持有。</p>
<p>由于 Handler 属于 TLS(Thread Local Storage) 变量, 生命周期和 Activity 是不一致的。因此这种实现方式一般很难保证跟 View 或者 Activity 的生命周期保持一致，故很容易导致无法正确释放。</p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class SampleActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">private final Handler mLeakyHandler = new Handler() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">// Post a message and delay its execution for 10 minutes.</span><br><span class="line">mLeakyHandler.postDelayed(new Runnable() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123; /* ... */ &#125;</span><br><span class="line">&#125;, 1000 * 60 * 10);</span><br><span class="line"></span><br><span class="line">// Go back to the previous Activity.</span><br><span class="line">finish();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该 SampleActivity 中声明了一个延迟10分钟执行的消息 Message，mLeakyHandler 将其 push 进了消息队列 MessageQueue 里。当该 Activity 被 finish() 掉时，延迟执行任务的 Message 还会继续存在于主线程中，它持有该 Activity 的 Handler 引用，所以此时 finish() 掉的 Activity 就不会被回收了从而造成内存泄漏（因 Handler 为非静态内部类，它会持有外部类的引用，在这里就是指 SampleActivity）。</p>
<p>修复方法：在 Activity 中避免使用非静态内部类，比如上面我们将 Handler 声明为静态的，则其存活期跟 Activity 的生命周期就无关了。同时通过弱引用的方式引入 Activity，避免直接将 Activity 作为 context 传进去，见下面代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class SampleActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Instances of static inner classes do not hold an implicit</span><br><span class="line">   * reference to their outer class.</span><br><span class="line">   */</span><br><span class="line">  private static class MyHandler extends Handler &#123;</span><br><span class="line">    private final WeakReference&lt;SampleActivity&gt; mActivity;</span><br><span class="line"></span><br><span class="line">    public MyHandler(SampleActivity activity) &#123;</span><br><span class="line">      mActivity = new WeakReference&lt;SampleActivity&gt;(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">      SampleActivity activity = mActivity.get();</span><br><span class="line">      if (activity != null) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private final MyHandler mHandler = new MyHandler(this);</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Instances of anonymous classes do not hold an implicit</span><br><span class="line">   * reference to their outer class when they are &quot;static&quot;.</span><br><span class="line">   */</span><br><span class="line">  private static final Runnable sRunnable = new Runnable() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123; /* ... */ &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    // Post a message and delay its execution for 10 minutes.</span><br><span class="line">    mHandler.postDelayed(sRunnable, 1000 * 60 * 10);</span><br><span class="line"></span><br><span class="line">    // Go back to the previous Activity.</span><br><span class="line">    finish();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综述，即推荐使用静态内部类 + WeakReference 这种方式。每次使用前注意判空。</p>
<p>前面提到了 WeakReference，所以这里就简单的说一下 Java 对象的几种引用类型。</p>
<p>Java对引用的分类有 Strong reference, SoftReference, WeakReference, PhatomReference 四种。</p>
<p><img src="https://gw.alicdn.com/tps/TB1U6TNLVXXXXchXFXXXXXXXXXX-644-546.jpg" alt=""></p>
<p>在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量应用软引用和弱引用技术。</p>
<p>软/弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。利用这个队列可以得知被回收的软/弱引用的对象列表，从而为缓冲器清除已失效的软/弱引用。</p>
<p>假设我们的应用会用到大量的默认图片，比如应用中有默认的头像，默认游戏图标等等，这些图片很多地方会用到。如果每次都去读取图片，由于读取文件需要硬件操作，速度较慢，会导致性能较低。所以我们考虑将图片缓存起来，需要的时候直接从内存中读取。但是，由于图片占用内存空间比较大，缓存很多图片需要很多的内存，就可能比较容易发生OutOfMemory异常。这时，我们可以考虑使用软/弱引用技术来避免这个问题发生。以下就是高速缓冲器的雏形：</p>
<p>首先定义一个HashMap，保存软引用对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Map &lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap &lt;String, SoftReference&lt;Bitmap&gt;&gt; ();</span><br></pre></td></tr></table></figure>
<p>再来定义一个方法，保存Bitmap的软引用到HashMap。</p>
<p><img src="https://gw.alicdn.com/tps/TB1oW_FLVXXXXXuaXXXXXXXXXXX-679-717.jpg" alt=""></p>
<p>使用软引用以后，在OutOfMemory异常发生之前，这些缓存的图片资源的内存空间可以被释放掉的，从而避免内存达到上限，避免Crash发生。</p>
<p>如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。</p>
<p>另外可以根据对象是否经常使用来判断选择软引用还是弱引用。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。</p>
<p>ok，继续回到主题。前面所说的，创建一个静态Handler内部类，然后对 Handler 持有的对象使用弱引用，这样在回收时也可以回收 Handler 持有的对象，但是这样做虽然避免了 Activity 泄漏，不过 Looper 线程的消息队列中还是可能会有待处理的消息，所以我们在 Activity 的 Destroy 时或者 Stop 时应该移除消息队列 MessageQueue 中的消息。</p>
<p>下面几个方法都可以移除 Message：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void removeCallbacks(Runnable r);</span><br><span class="line"></span><br><span class="line">public final void removeCallbacks(Runnable r, Object token);</span><br><span class="line"></span><br><span class="line">public final void removeCallbacksAndMessages(Object token);</span><br><span class="line"></span><br><span class="line">public final void removeMessages(int what);</span><br><span class="line"></span><br><span class="line">public final void removeMessages(int what, Object object);</span><br></pre></td></tr></table></figure>
<p>###尽量避免使用 static 成员变量</p>
<p>如果成员变量被声明为 static，那我们都知道其生命周期将与整个app进程生命周期一样。</p>
<p>这会导致一系列问题，如果你的app进程设计上是长驻内存的，那即使app切到后台，这部分内存也不会被释放。按照现在手机app内存管理机制，占内存较大的后台进程将优先回收，yi’wei如果此app做过进程互保保活，那会造成app在后台频繁重启。当手机安装了你参与开发的app以后一夜时间手机被消耗空了电量、流量，你的app不得不被用户卸载或者静默。</p>
<p>这里修复的方法是：</p>
<p>不要在类初始时初始化静态成员。可以考虑lazy初始化。<br>架构设计上要思考是否真的有必要这样做，尽量避免。如果架构需要这么设计，那么此对象的生命周期你有责任管理起来。</p>
<p>###避免 override finalize()</p>
<p>1、finalize 方法被执行的时间不确定，不能依赖与它来释放紧缺的资源。时间不确定的原因是：<br>        虚拟机调用GC的时间不确定<br>        Finalize daemon线程被调度到的时间不确定</p>
<p>2、finalize 方法只会被执行一次，即使对象被复活，如果已经执行过了 finalize 方法，再次被 GC 时也不会再执行了，原因是：</p>
<p>含有 finalize 方法的 object 是在 new 的时候由虚拟机生成了一个 finalize reference 在来引用到该Object的，而在 finalize 方法执行的时候，该 object 所对应的 finalize Reference 会被释放掉，即使在这个时候把该 object 复活(即用强引用引用住该 object )，再第二次被 GC 的时候由于没有了 finalize reference 与之对应，所以 finalize 方法不会再执行。</p>
<p>3、含有Finalize方法的object需要至少经过两轮GC才有可能被释放。</p>
<p>###资源未关闭造成的内存泄漏</p>
<p>对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</p>
<p>###一些不良代码造成的内存压力</p>
<p>有些代码并不造成内存泄露，但是它们，或是对没使用的内存没进行有效及时的释放，或是没有有效的利用已有的对象而是频繁的申请新内存。</p>
<p>比如：<br>        Bitmap 没调用 recycle()方法，对于 Bitmap 对象在不使用时,我们应该先调用 recycle() 释放内存，然后才它设置为 null. 因为加载 Bitmap 对象的内存空间，一部分是 java 的，一部分 C 的（因为 Bitmap 分配的底层是通过 JNI 调用的 )。 而这个 recyle() 就是针对 C 部分的内存释放。<br>        构造 Adapter 时，没有使用缓存的 convertView ,每次都在创建新的 converView。这里推荐使用 ViewHolder。</p>
<p>##总结</p>
<p>对 Activity 等组件的引用应该控制在 Activity 的生命周期之内； 如果不能就考虑使用 getApplicationContext 或者 getApplication，以避免 Activity 被外部长生命周期的对象引用而泄露。</p>
<p>尽量不要在静态变量或者静态内部类中使用非静态外部成员变量（包括context )，即使要使用，也要考虑适时把外部成员变量置空；也可以在内部类中使用弱引用来引用外部类的变量。</p>
<p>对于生命周期比Activity长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样做避免内存泄漏：</p>
<pre><code>将内部类改为静态内部类
静态内部类中使用弱引用来引用外部类的成员变量
</code></pre><p>Handler 的持有的引用对象最好使用弱引用，资源释放时也可以清空 Handler 里面的消息。比如在 Activity onStop 或者 onDestroy 的时候，取消掉该 Handler 对象的 Message和 Runnable.</p>
<p>在 Java 的实现过程中，也要考虑其对象释放，最好的方法是在不使用某对象时，显式地将此对象赋值为 null，比如使用完Bitmap 后先调用 recycle()，再赋为null,清空对图片等资源有直接引用或者间接引用的数组（使用 array.clear() ; array = null）等，最好遵循谁创建谁释放的原则。</p>
<p>正确关闭资源，对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销。</p>
<p>保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期。</p>
]]></content>
      
        <categories>
            
            <category> Android 优化 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> android </tag>
            
            <tag> 内存泄露 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo使用教程]]></title>
      <url>/2017/12/05/hexo%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h3 id="下载安装Git并配置"><a href="#下载安装Git并配置" class="headerlink" title="下载安装Git并配置"></a>下载安装Git并配置</h3><p><em>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git 工具</a>，点击下载并安装。
</em>配置公钥<br>1.在终端中输入ssh-keygen -t rsa -C 你的邮箱<br>比如 ：ssh-keygen -t rsa -C  hck@.com<br>然后一直回车，就行了<br>最后得到如图<br><img src="/img/hexo使用教程/1.png" alt="1.png"><br><a id="more"></a><br>2.它会生成一个 id _rsa.pub 文件，看上面截图，它有 保存路径的地址说明，按照保存路径找到文件，打开，复制里面的内容<br>登录到github，点击右上角 小三角，出现如图<br><img src="/img/hexo使用教程/2.png" alt="2.png"></p>
<p>3.点击setting -&gt; sshkey -&gt; new ssh key（右上）<br>在页面随便填入一个title，然后key里面，把刚才复制的那个文本信息拷贝进去<br><img src="/img/hexo使用教程/3.png" alt="3.png"><br>点击add ssh key ，没有提示错误，就ok了.<br>4.测试SSH Key是否设置成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &apos;github.com (192.30.253.113)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br></pre></td></tr></table></figure>
<p>是否继续连接?输入yes<br>输出如下,则表示ssh key设置成功.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi xxxx! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure></p>
<p>5.本地用户信息配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git config -l  查看当前配置信息</span><br><span class="line">credential.helper=osxkeychain</span><br><span class="line">user.name=adlerkismet</span><br><span class="line">user.email=sckismet07@gmail.com</span><br><span class="line">filter.lfs.clean=git-lfs clean -- %f</span><br><span class="line">filter.lfs.smudge=git-lfs smudge -- %f</span><br><span class="line">filter.lfs.process=git-lfs filter-process</span><br><span class="line">filter.lfs.required=true</span><br></pre></td></tr></table></figure></p>
<p>6.全局用户信息配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name J_mialbox</span><br><span class="line">git config --global user.email J_mialbox@163.com</span><br><span class="line"></span><br><span class="line">//信息保存位置:chengaojian(用户名)</span><br><span class="line">/Users/chengaojian/.gitconfig</span><br><span class="line"></span><br><span class="line">打开gitconfig信息如下:</span><br><span class="line">[user]</span><br><span class="line">    name = J_mialbox</span><br><span class="line">    email = J_mialbox@163.com</span><br><span class="line"></span><br><span class="line">git log  --查看历史</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="下载安装node-js"><a href="#下载安装node-js" class="headerlink" title="下载安装node.js"></a>下载安装node.js</h3><p>1.<a href="https://link.jianshu.com/?t=https://nodejs.org/en/" target="_blank" rel="noopener">node.js下载地址</a><br>2.安装步骤：一路默认就行（安装路径根据自己需要更改）<br>3.windows平台下可能需要配置路径,具体看<a href="http://blog.csdn.net/xxmeng2012/article/details/51492149" target="_blank" rel="noopener">这篇文章</a>.</p>
<hr>
<h3 id="下载blog源文件备份并配置"><a href="#下载blog源文件备份并配置" class="headerlink" title="下载blog源文件备份并配置"></a>下载blog源文件备份并配置</h3><p>1.在配置完github密钥以及安装好npm的情况下,在终端cd到想要存放blog源文件的目录下,<code>git clone https://github.com/GosuncnStudio/Blog.git</code>.把博客源文件拷贝到本地路径,并与github产生依赖.<br>2.使用终端全局安装hexo,在终端输入<code>npm install -g hexo</code><br>3.在终端输入<code>npm update</code>,npm会根据<code>package.json</code>文件而自动下载依赖的包.<br>4.若没提示错误则配置完成,可使用hexo进行发布blog.</p>
<hr>
<h3 id="使用hexo发布"><a href="#使用hexo发布" class="headerlink" title="使用hexo发布"></a>使用hexo发布</h3><ul>
<li><code>hexo new &quot;文章名&quot;</code>例如<code>hexo new &quot;测试文档&quot;</code>可生成一篇名为”测试文档”的新文章,存放在/source/_post/目录下,用markdown编辑器可以打开编辑.具体的md语法参照<a href="https://gosuncnstudio.github.io/2017/12/05/hexo%E6%A0%B7%E5%BC%8F/">hexo样式</a>.</li>
<li><code>hexo clean</code> 清除编译完成的public文件夹以及数据库文件</li>
<li><code>hexo generate 或 hexo g</code> 编译源文件生产静态网页</li>
<li><code>hexo server 或 hexo s</code> 开启服务,可通过<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>预览</li>
<li><code>hexo deploy 或 hexo d</code> 部署发布到网站上</li>
<li>通常的部署只需要三步,在终端hexo clean之后,hexo g &amp;&amp; hexo d.如图<br><img src="/img/hexo使用教程/5.png" alt="5.png"></li>
<li>部署成功后把源文件的修改提交到github(地址:<a href="https://github.com/GosuncnMobile/Blog.git" target="_blank" rel="noopener">https://github.com/GosuncnMobile/Blog.git</a>)</li>
<li>第一次发布需要账号密码,看部门群公告.<br>(如果报权限拒绝，则到控制面板中找到用户账户，在普通凭据中修改github的账号密码)</li>
</ul>
<hr>
<h3 id="部署一个全新的hexo博客"><a href="#部署一个全新的hexo博客" class="headerlink" title="部署一个全新的hexo博客"></a>部署一个全新的hexo博客</h3><p>1.先配置git密钥以及安装npm.<br>2.终端输入命令：<code>npm install -g hexo</code>,全局安装hexo.<br>  若被墙,则使用<a href="http://npm.taobao.org/" target="_blank" rel="noopener">淘宝NPM镜像</a><br>  输入以下命令<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">cnpm install -g hexo-cli</span><br><span class="line">cnpm install hexo --save</span><br></pre></td></tr></table></figure></p>
<p>3.输入<code>hexo -version</code>,若出现如下信息,则安装成功.<br><img src="/img/hexo使用教程/4.jpg" alt="4.jpg"><br>4.安装<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>自动部署发布工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git  --save</span><br></pre></td></tr></table></figure></p>
<p>5.接下来的新建一个blog,cd到想要存放blog的目录.终端执行<code>hexo init</code>,要求文件夹为空.</p>
<hr>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>更多hexo的拓展使用参照<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo中文文档</a>以及<a href="http://moxfive.coding.me/yelee/" target="_blank" rel="noopener">yelee主题使用文档</a>.</p>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="http://www.jianshu.com/p/6ae3697a7c93" target="_blank" rel="noopener">Git的使用以及GitHub的配置</a><br>2.<a href="http://blog.csdn.net/hhhccckkk/article/details/50737077" target="_blank" rel="noopener">github配置密钥</a><br>3.<a href="http://www.jianshu.com/p/189fd945f38f" target="_blank" rel="noopener">搭建个人博客-hexo+github详细完整步骤</a><br>4.<a href="http://blog.csdn.net/xxmeng2012/article/details/51492149" target="_blank" rel="noopener"> NodeJS、NPM安装配置步骤(windows版本)</a></p>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo样式及md语法教程]]></title>
      <url>/2017/12/05/hexo%E6%A0%B7%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="生成一篇新文章或者界面"><a href="#生成一篇新文章或者界面" class="headerlink" title="生成一篇新文章或者界面"></a>生成一篇新文章或者界面</h3><p>进入到blog目录下,终端输入<code>hexo new [文章类型] &quot;文章名字&quot;</code>([文章类型]可以省略),可生成一篇新文章,如图<br><img src="../img/hexo样式/6.png" alt="3.png"><br>文章类型可选种类:</p>
<ul>
<li>posts 普通文章,在文章列表里面显示</li>
<li>page 界面,生成一个新界面,如开源项目主页,及优秀推荐等形式</li>
<li>drafts 草稿,保存在资源目录,但没发表在文章目录上</li>
</ul>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p><strong>注意具体标题和显示标题的#级数之间应该有空格,否则hexo可能识别不了该标题.如图</strong><br><img src="../img/hexo样式/3.png" alt="3.png"><br><a id="more"></a></p>
<hr>
<h3 id="首页显示文章的摘要设置"><a href="#首页显示文章的摘要设置" class="headerlink" title="首页显示文章的摘要设置"></a>首页显示文章的摘要设置</h3><p><strong>在正文的摘要和余下全文之间插入<code>&lt;!--more--&gt;</code>,如图</strong><br><img src="../img/hexo样式/4.png" alt="4.png"></p>
<hr>
<h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>使用格式为:<br><img src="../img/hexo样式/5.png" alt="5.png"><br>具体各种语言的languageKey,参见<a href="http://blog.csdn.net/u013553529/article/details/50629055" target="_blank" rel="noopener">md语法高亮</a></p>
<h4 id="oc"><a href="#oc" class="headerlink" title="oc"></a>oc</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)lt_setBackgroundColor:(<span class="built_in">UIColor</span> *)backgroundColor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.overlay) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setBackgroundImage:[<span class="built_in">UIImage</span> new] forBarMetrics:<span class="built_in">UIBarMetricsDefault</span>];</span><br><span class="line">        <span class="keyword">self</span>.overlay = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">-20</span>, [<span class="built_in">UIScreen</span> mainScreen].bounds.size.width, <span class="built_in">CGRectGetHeight</span>(<span class="keyword">self</span>.bounds) + <span class="number">20</span>)];</span><br><span class="line">        <span class="keyword">self</span>.overlay.userInteractionEnabled = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">self</span>.overlay.autoresizingMask = <span class="built_in">UIViewAutoresizingFlexibleWidth</span>|<span class="built_in">UIViewAutoresizingFlexibleHeight</span>;</span><br><span class="line">        [<span class="keyword">self</span> insertSubview:<span class="keyword">self</span>.overlay atIndex:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.overlay.backgroundColor = backgroundColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initAreaData</span><span class="params">(List&lt;AreaInfo&gt; data)</span> </span>&#123;</span><br><span class="line">        areaInfos = data;</span><br><span class="line">        List&lt;String&gt; list = Stream.of(data).map(AreaInfo::getName).collect(Collectors.toList());</span><br><span class="line">        adapter.setList(list);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (list.size() &lt; <span class="number">7</span>) &#123;</span><br><span class="line">            getWindow().setLayout(WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getWindow().setLayout(WindowManager.LayoutParams.WRAP_CONTENT, DensityUtils.dp2px(getApplication(), <span class="number">340</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">style</span>=<span class="string">"@style/LinearHorizontalStyle"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">"@dimen/y34"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:padding</span>=<span class="string">"0dp"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/tv_person_name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">"@style/ListItem.Item"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:paddingLeft</span>=<span class="string">"2dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">"0.6"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:text</span>=<span class="string">"欧阳雷锋"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> CMFormatDescriptionRef <span class="title">createFormatDescriptionFromH264Parameter</span><span class="params">(GSFrameParser *frameData, <span class="keyword">uint32_t</span> frameSize)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    CMFormatDescriptionRef fmt_desc = <span class="literal">NULL</span>;</span><br><span class="line">    OSStatus status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *<span class="keyword">const</span> parameterSetPointers[<span class="number">2</span>] = &#123;frameData.sps,frameData.pps&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> parmeterSetSizes[<span class="number">2</span>] = &#123;frameData.spsSize,frameData.ppsSize&#125;;</span><br><span class="line">    status = CMVideoFormatDescriptionCreateFromH264ParameterSets(kCFAllocatorDefault, <span class="number">2</span>, parameterSetPointers, parmeterSetSizes, <span class="number">4</span>, &amp;fmt_desc);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == noErr)</span><br><span class="line">        <span class="keyword">return</span> fmt_desc;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><p><code>**加黑**</code><br><strong>加黑</strong></p>
<p><code>*强调(斜体)*</code><br><em>强调(斜体)</em></p>
<p><code>~~删除线~~</code><br><del>删除线</del></p>
<p><code>&gt; 区块应用</code></p>
<blockquote>
<p>区块应用</p>
</blockquote>
<hr>
<h3 id="图片与超链接"><a href="#图片与超链接" class="headerlink" title="图片与超链接"></a>图片与超链接</h3><p><strong>超链接</strong><br><code>[高新兴移动开发小组](https://gosuncnstudio.github.io/)</code><br><a href="https://gosuncnstudio.github.io/">高新兴移动开发小组</a></p>
<p><strong>网络图片调用</strong><br><code>![gosuncn](https://gosuncnstudio.github.io/img/avatar.png)</code><br><img src="https://gosuncnstudio.github.io/img/avatar.png" alt="gosuncn"></p>
<p><strong>本地图片调用</strong><br><code>![gosuncn](../img/avatar.png)</code><br><img src="../img/avatar.png" alt="gosuncn"></p>
<hr>
<h3 id="文章中添加图片的方法"><a href="#文章中添加图片的方法" class="headerlink" title="文章中添加图片的方法"></a>文章中添加图片的方法</h3><ul>
<li>图片都存放在source/img的路径下,每篇文章新建一个文件夹存放该文章所需要的图片.按顺序从1开始排列.</li>
<li>把要用的图片先放在上述的路径下,直接拖进Markdown编译器并删除引用路径<code>/img/...</code>之前的路径,就可以完成引用.如图<br><img src="../img/hexo样式/1.png" alt="1.png"></li>
</ul>
<hr>
<h3 id="添加分类和标签"><a href="#添加分类和标签" class="headerlink" title="添加分类和标签"></a>添加分类和标签</h3><ul>
<li>在每篇文章自动生成的categories添加分类(最好只有一个分类),在tags后面添加标签(可以有多个标签).如图<br><img src="../img/hexo样式/2.png" alt="2.png"></li>
</ul>
<hr>
<h3 id="github挂件"><a href="#github挂件" class="headerlink" title="github挂件"></a>github挂件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;github-widget&quot; data-repo=&quot;GosuncnStudio/AppVerMgt&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<div class="github-widget" data-repo="GosuncnStudio/AppVerMgt"></div>

<hr>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 水果        | 价格    |  数量  |</span><br><span class="line">    | --------   | -----:   | :----: |</span><br><span class="line">    | 香蕉        | $1      |   5    |</span><br><span class="line">    | 苹果        | $1      |   6    |</span><br><span class="line">    | 草莓        | $1      |   7    |</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>水果</th>
<th style="text-align:right">价格</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>香蕉</td>
<td style="text-align:right">$1</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td>苹果</td>
<td style="text-align:right">$1</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td>草莓</td>
<td style="text-align:right">$1</td>
<td style="text-align:center">7</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="http://blog.csdn.net/u013553529/article/details/50629055" target="_blank" rel="noopener">md语法高亮</a><br>2.<a href="https://www.cnblogs.com/liugang-vip/p/6337580.html" target="_blank" rel="noopener">md基本语法</a><br>3.<a href="http://wowubuntu.com/markdown/index.html#overview" target="_blank" rel="noopener">Markdown 语法说明 (简体中文版)</a><br>4.<a href="http://moxfive.coding.me/yelee/" target="_blank" rel="noopener">Yelee 主题使用说明</a></p>
]]></content>
      
        <categories>
            
            <category> demo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GXXVideoPlayer配置]]></title>
      <url>/2017/12/04/GXXVideoPlayer%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h4 id="在Link-Binary-With-Libraries中添加libGXXVideoPlayer-a和libvideostack-a两个静态库。"><a href="#在Link-Binary-With-Libraries中添加libGXXVideoPlayer-a和libvideostack-a两个静态库。" class="headerlink" title="在Link Binary With Libraries中添加libGXXVideoPlayer.a和libvideostack.a两个静态库。"></a>在Link Binary With Libraries中添加libGXXVideoPlayer.a和libvideostack.a两个静态库。</h4><h4 id="在User-Header-Search-Paths中拖入GXXVideoPlayer和videostack两个库的地址。"><a href="#在User-Header-Search-Paths中拖入GXXVideoPlayer和videostack两个库的地址。" class="headerlink" title="在User Header Search Paths中拖入GXXVideoPlayer和videostack两个库的地址。"></a>在User Header Search Paths中拖入GXXVideoPlayer和videostack两个库的地址。</h4><p><img src="/img/GXXVideoPlayer配置/1.jpeg" alt="1.jpeg"></p>
<h4 id="在Link-Binary-With-Libraries中加入7个动态库：libstdc-6-0-9-tbd-libz-1-2-8-tbd-libz-tbd-libbz2-tbd-libiconv-tbd-VideoToolbox-framework-CoreMedia-framework"><a href="#在Link-Binary-With-Libraries中加入7个动态库：libstdc-6-0-9-tbd-libz-1-2-8-tbd-libz-tbd-libbz2-tbd-libiconv-tbd-VideoToolbox-framework-CoreMedia-framework" class="headerlink" title="在Link Binary With Libraries中加入7个动态库：libstdc++.6.0.9.tbd,libz.1.2.8.tbd,libz.tbd,libbz2.tbd,libiconv.tbd, VideoToolbox.framework,CoreMedia.framework"></a>在Link Binary With Libraries中加入7个动态库：libstdc++.6.0.9.tbd,libz.1.2.8.tbd,libz.tbd,libbz2.tbd,libiconv.tbd, VideoToolbox.framework,CoreMedia.framework</h4><a id="more"></a>
<p><img src="/img/GXXVideoPlayer配置/2.jpeg" alt="2.jpeg"></p>
<h4 id="在Other-Linker-Flags添加-ObjC-lbz2-liconv（注意大小写）"><a href="#在Other-Linker-Flags添加-ObjC-lbz2-liconv（注意大小写）" class="headerlink" title="在Other Linker Flags添加-ObjC,-lbz2,-liconv（注意大小写）"></a>在Other Linker Flags添加-ObjC,-lbz2,-liconv（注意大小写）</h4><p><img src="/img/GXXVideoPlayer配置/3.jpeg" alt="3.jpeg"></p>
<h4 id="在Preprocessor-Marcos中，Debug添加：DEBUG-1-LINUX-IOS-SD-WEBP-Release添加：-IOS-LINUX"><a href="#在Preprocessor-Marcos中，Debug添加：DEBUG-1-LINUX-IOS-SD-WEBP-Release添加：-IOS-LINUX" class="headerlink" title="在Preprocessor Marcos中，Debug添加：DEBUG=1,_LINUX,_IOS,SD_WEBP,Release添加：_IOS,_LINUX"></a>在Preprocessor Marcos中，Debug添加：DEBUG=1,_LINUX,_IOS,SD_WEBP,Release添加：_IOS,_LINUX</h4><p><img src="/img/GXXVideoPlayer配置/4.jpeg" alt="4.jpeg"></p>
<p><img src="/img/GXXVideoPlayer配置/5.jpeg" alt="5.jpeg"></p>
<p><img src="/img/GXXVideoPlayer配置/6.jpeg" alt="6.jpeg"></p>
<h4 id="把项目中至少一个文件的-m后缀改成-mm支持c-（例如修改AppDelegate-m为AppDelegate-mm）"><a href="#把项目中至少一个文件的-m后缀改成-mm支持c-（例如修改AppDelegate-m为AppDelegate-mm）" class="headerlink" title="把项目中至少一个文件的.m后缀改成.mm支持c++.（例如修改AppDelegate.m为AppDelegate.mm）"></a>把项目中至少一个文件的.m后缀改成.mm支持c++.（例如修改AppDelegate.m为AppDelegate.mm）</h4><p><img src="/img/GXXVideoPlayer配置/7.jpeg" alt="7.jpeg"></p>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
            <tag> video </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
